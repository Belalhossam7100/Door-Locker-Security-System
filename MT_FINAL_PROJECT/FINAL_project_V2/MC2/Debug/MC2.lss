
MC2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000253c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000008  00800060  0000253c  000025d0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000001b  00800068  00800068  000025d8  2**0
                  ALLOC
  3 .stab         00002a6c  00000000  00000000  000025d8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000170c  00000000  00000000  00005044  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  00006750  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  00006890  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  00006a00  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  00008649  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  00009534  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  0000a2e4  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  0000a444  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  0000a6d1  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0000ae9f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 25 0b 	jmp	0x164a	; 0x164a <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 e9 0a 	jmp	0x15d2	; 0x15d2 <__vector_9>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_clear_bss>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a8 e6       	ldi	r26, 0x68	; 104
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	01 c0       	rjmp	.+2      	; 0x6a <.do_clear_bss_start>

00000068 <.do_clear_bss_loop>:
      68:	1d 92       	st	X+, r1

0000006a <.do_clear_bss_start>:
      6a:	a3 38       	cpi	r26, 0x83	; 131
      6c:	b1 07       	cpc	r27, r17
      6e:	e1 f7       	brne	.-8      	; 0x68 <.do_clear_bss_loop>

00000070 <__do_copy_data>:
      70:	10 e0       	ldi	r17, 0x00	; 0
      72:	a0 e6       	ldi	r26, 0x60	; 96
      74:	b0 e0       	ldi	r27, 0x00	; 0
      76:	ec e3       	ldi	r30, 0x3C	; 60
      78:	f5 e2       	ldi	r31, 0x25	; 37
      7a:	02 c0       	rjmp	.+4      	; 0x80 <.do_copy_data_start>

0000007c <.do_copy_data_loop>:
      7c:	05 90       	lpm	r0, Z+
      7e:	0d 92       	st	X+, r0

00000080 <.do_copy_data_start>:
      80:	a8 36       	cpi	r26, 0x68	; 104
      82:	b1 07       	cpc	r27, r17
      84:	d9 f7       	brne	.-10     	; 0x7c <.do_copy_data_loop>
      86:	0e 94 05 0a 	call	0x140a	; 0x140a <main>
      8a:	0c 94 9c 12 	jmp	0x2538	; 0x2538 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 65 12 	jmp	0x24ca	; 0x24ca <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a0 e6       	ldi	r26, 0x60	; 96
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 81 12 	jmp	0x2502	; 0x2502 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 71 12 	jmp	0x24e2	; 0x24e2 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 8d 12 	jmp	0x251a	; 0x251a <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 71 12 	jmp	0x24e2	; 0x24e2 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 8d 12 	jmp	0x251a	; 0x251a <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 65 12 	jmp	0x24ca	; 0x24ca <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	80 e6       	ldi	r24, 0x60	; 96
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 81 12 	jmp	0x2502	; 0x2502 <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 71 12 	jmp	0x24e2	; 0x24e2 <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 8d 12 	jmp	0x251a	; 0x251a <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 71 12 	jmp	0x24e2	; 0x24e2 <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 8d 12 	jmp	0x251a	; 0x251a <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 71 12 	jmp	0x24e2	; 0x24e2 <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 8d 12 	jmp	0x251a	; 0x251a <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 75 12 	jmp	0x24ea	; 0x24ea <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 91 12 	jmp	0x2522	; 0x2522 <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <Buzzer_init>:
 */
#include"Buzzer.h"
#include "gpio.h"
#include "std_types.h"

void Buzzer_init(){
     b46:	df 93       	push	r29
     b48:	cf 93       	push	r28
     b4a:	cd b7       	in	r28, 0x3d	; 61
     b4c:	de b7       	in	r29, 0x3e	; 62
	GPIO_setupPinDirection(BUZZER_PORT,BUZZER_PIN,PIN_OUTPUT);//set up buzz pin as output pin
     b4e:	82 e0       	ldi	r24, 0x02	; 2
     b50:	62 e0       	ldi	r22, 0x02	; 2
     b52:	41 e0       	ldi	r20, 0x01	; 1
     b54:	0e 94 93 0c 	call	0x1926	; 0x1926 <GPIO_setupPinDirection>
	GPIO_writePin(BUZZER_PORT,BUZZER_PIN,LOGIC_LOW);//buzzer off
     b58:	82 e0       	ldi	r24, 0x02	; 2
     b5a:	62 e0       	ldi	r22, 0x02	; 2
     b5c:	40 e0       	ldi	r20, 0x00	; 0
     b5e:	0e 94 7e 0d 	call	0x1afc	; 0x1afc <GPIO_writePin>
}
     b62:	cf 91       	pop	r28
     b64:	df 91       	pop	r29
     b66:	08 95       	ret

00000b68 <Buzzer_on>:
void Buzzer_on(void){
     b68:	df 93       	push	r29
     b6a:	cf 93       	push	r28
     b6c:	cd b7       	in	r28, 0x3d	; 61
     b6e:	de b7       	in	r29, 0x3e	; 62
	GPIO_writePin(BUZZER_PORT,BUZZER_PIN,LOGIC_HIGH);//buzzer on
     b70:	82 e0       	ldi	r24, 0x02	; 2
     b72:	62 e0       	ldi	r22, 0x02	; 2
     b74:	41 e0       	ldi	r20, 0x01	; 1
     b76:	0e 94 7e 0d 	call	0x1afc	; 0x1afc <GPIO_writePin>
}
     b7a:	cf 91       	pop	r28
     b7c:	df 91       	pop	r29
     b7e:	08 95       	ret

00000b80 <Buzzer_off>:
void Buzzer_off(void){
     b80:	df 93       	push	r29
     b82:	cf 93       	push	r28
     b84:	cd b7       	in	r28, 0x3d	; 61
     b86:	de b7       	in	r29, 0x3e	; 62
	GPIO_writePin(BUZZER_PORT,BUZZER_PIN,LOGIC_LOW);//buzzer off
     b88:	82 e0       	ldi	r24, 0x02	; 2
     b8a:	62 e0       	ldi	r22, 0x02	; 2
     b8c:	40 e0       	ldi	r20, 0x00	; 0
     b8e:	0e 94 7e 0d 	call	0x1afc	; 0x1afc <GPIO_writePin>
}
     b92:	cf 91       	pop	r28
     b94:	df 91       	pop	r29
     b96:	08 95       	ret

00000b98 <check_created_password>:
/************************************GLOBAL VARBS*****************************************/
uint8 counter_for_buzzer;
uint8 pass_in_EEPROM[password_length];//will be used to give the user access to use main options

/******************************Functions**************************************/
void check_created_password(uint8 *control_sys_password){/**step1**/
     b98:	0f 93       	push	r16
     b9a:	1f 93       	push	r17
     b9c:	df 93       	push	r29
     b9e:	cf 93       	push	r28
     ba0:	cd b7       	in	r28, 0x3d	; 61
     ba2:	de b7       	in	r29, 0x3e	; 62
     ba4:	6d 97       	sbiw	r28, 0x1d	; 29
     ba6:	0f b6       	in	r0, 0x3f	; 63
     ba8:	f8 94       	cli
     baa:	de bf       	out	0x3e, r29	; 62
     bac:	0f be       	out	0x3f, r0	; 63
     bae:	cd bf       	out	0x3d, r28	; 61
     bb0:	9d 8f       	std	Y+29, r25	; 0x1d
     bb2:	8c 8f       	std	Y+28, r24	; 0x1c
	uint8 reentered_created_password[password_length];
	uint8 retry_pass_control[password_length];
	uint8 counter,re_counter;
	uint8 pass_missmatch=0;
     bb4:	1f 86       	std	Y+15, r1	; 0x0f

	receive_user_entered_pass(control_sys_password);
     bb6:	8c 8d       	ldd	r24, Y+28	; 0x1c
     bb8:	9d 8d       	ldd	r25, Y+29	; 0x1d
     bba:	0e 94 d0 06 	call	0xda0	; 0xda0 <receive_user_entered_pass>

	while(UART_recieveByte() != RENTERED_CREATED_PASS){}/**first time:re-entered password**/
     bbe:	0e 94 c8 11 	call	0x2390	; 0x2390 <UART_recieveByte>
     bc2:	81 31       	cpi	r24, 0x11	; 17
     bc4:	e1 f7       	brne	.-8      	; 0xbbe <check_created_password+0x26>
	for(re_counter=0;re_counter<(password_length);re_counter++)
     bc6:	18 8a       	std	Y+16, r1	; 0x10
     bc8:	13 c0       	rjmp	.+38     	; 0xbf0 <check_created_password+0x58>
		{
		while(UART_recieveByte() != RENTERED_CREATED_PASS){}/**first time:re-entered password**/
     bca:	0e 94 c8 11 	call	0x2390	; 0x2390 <UART_recieveByte>
     bce:	81 31       	cpi	r24, 0x11	; 17
     bd0:	e1 f7       	brne	.-8      	; 0xbca <check_created_password+0x32>
		reentered_created_password[re_counter] = UART_recieveByte();//Receive password
     bd2:	88 89       	ldd	r24, Y+16	; 0x10
     bd4:	08 2f       	mov	r16, r24
     bd6:	10 e0       	ldi	r17, 0x00	; 0
     bd8:	0e 94 c8 11 	call	0x2390	; 0x2390 <UART_recieveByte>
     bdc:	28 2f       	mov	r18, r24
     bde:	ce 01       	movw	r24, r28
     be0:	42 96       	adiw	r24, 0x12	; 18
     be2:	fc 01       	movw	r30, r24
     be4:	e0 0f       	add	r30, r16
     be6:	f1 1f       	adc	r31, r17
     be8:	20 83       	st	Z, r18
	uint8 pass_missmatch=0;

	receive_user_entered_pass(control_sys_password);

	while(UART_recieveByte() != RENTERED_CREATED_PASS){}/**first time:re-entered password**/
	for(re_counter=0;re_counter<(password_length);re_counter++)
     bea:	88 89       	ldd	r24, Y+16	; 0x10
     bec:	8f 5f       	subi	r24, 0xFF	; 255
     bee:	88 8b       	std	Y+16, r24	; 0x10
     bf0:	88 89       	ldd	r24, Y+16	; 0x10
     bf2:	85 30       	cpi	r24, 0x05	; 5
     bf4:	50 f3       	brcs	.-44     	; 0xbca <check_created_password+0x32>
		reentered_created_password[re_counter] = UART_recieveByte();//Receive password
		}


	/********CHECK BOTH PASSWORDS SEND BY MC1 (MC2 RESPONSE)******************/
	for(counter=0;counter<(password_length);counter++)
     bf6:	19 8a       	std	Y+17, r1	; 0x11
     bf8:	1b c0       	rjmp	.+54     	; 0xc30 <check_created_password+0x98>
	{
		if(reentered_created_password[counter]!=control_sys_password[counter])
     bfa:	89 89       	ldd	r24, Y+17	; 0x11
     bfc:	28 2f       	mov	r18, r24
     bfe:	30 e0       	ldi	r19, 0x00	; 0
     c00:	ce 01       	movw	r24, r28
     c02:	42 96       	adiw	r24, 0x12	; 18
     c04:	fc 01       	movw	r30, r24
     c06:	e2 0f       	add	r30, r18
     c08:	f3 1f       	adc	r31, r19
     c0a:	40 81       	ld	r20, Z
     c0c:	89 89       	ldd	r24, Y+17	; 0x11
     c0e:	28 2f       	mov	r18, r24
     c10:	30 e0       	ldi	r19, 0x00	; 0
     c12:	8c 8d       	ldd	r24, Y+28	; 0x1c
     c14:	9d 8d       	ldd	r25, Y+29	; 0x1d
     c16:	fc 01       	movw	r30, r24
     c18:	e2 0f       	add	r30, r18
     c1a:	f3 1f       	adc	r31, r19
     c1c:	80 81       	ld	r24, Z
     c1e:	48 17       	cp	r20, r24
     c20:	21 f0       	breq	.+8      	; 0xc2a <check_created_password+0x92>
		{
			pass_missmatch++;
     c22:	8f 85       	ldd	r24, Y+15	; 0x0f
     c24:	8f 5f       	subi	r24, 0xFF	; 255
     c26:	8f 87       	std	Y+15, r24	; 0x0f
     c28:	06 c0       	rjmp	.+12     	; 0xc36 <check_created_password+0x9e>
		reentered_created_password[re_counter] = UART_recieveByte();//Receive password
		}


	/********CHECK BOTH PASSWORDS SEND BY MC1 (MC2 RESPONSE)******************/
	for(counter=0;counter<(password_length);counter++)
     c2a:	89 89       	ldd	r24, Y+17	; 0x11
     c2c:	8f 5f       	subi	r24, 0xFF	; 255
     c2e:	89 8b       	std	Y+17, r24	; 0x11
     c30:	89 89       	ldd	r24, Y+17	; 0x11
     c32:	85 30       	cpi	r24, 0x05	; 5
     c34:	10 f3       	brcs	.-60     	; 0xbfa <check_created_password+0x62>
			break;//no need to compare further
		}
	}
	/**************************************************************************/

	if(pass_missmatch==0)//match bet it and the saved pass in EEPROM
     c36:	8f 85       	ldd	r24, Y+15	; 0x0f
     c38:	88 23       	and	r24, r24
     c3a:	09 f0       	breq	.+2      	; 0xc3e <check_created_password+0xa6>
     c3c:	7f c0       	rjmp	.+254    	; 0xd3c <check_created_password+0x1a4>
			{
			UART_sendByte(PASSWORD_CHECKING_FINISHED);/**second time:checking **/
     c3e:	82 e1       	ldi	r24, 0x12	; 18
     c40:	0e 94 b1 11 	call	0x2362	; 0x2362 <UART_sendByte>
			UART_sendByte(PASSWORDS_MATCH);/**second time:match **/
     c44:	83 e1       	ldi	r24, 0x13	; 19
     c46:	0e 94 b1 11 	call	0x2362	; 0x2362 <UART_sendByte>
			/*******save password into the EEEPROM*******/
			Save_to_EEPROM(reentered_created_password);
     c4a:	ce 01       	movw	r24, r28
     c4c:	42 96       	adiw	r24, 0x12	; 18
     c4e:	0e 94 9d 09 	call	0x133a	; 0x133a <Save_to_EEPROM>
     c52:	80 e0       	ldi	r24, 0x00	; 0
     c54:	90 e0       	ldi	r25, 0x00	; 0
     c56:	a0 ef       	ldi	r26, 0xF0	; 240
     c58:	b1 e4       	ldi	r27, 0x41	; 65
     c5a:	8b 87       	std	Y+11, r24	; 0x0b
     c5c:	9c 87       	std	Y+12, r25	; 0x0c
     c5e:	ad 87       	std	Y+13, r26	; 0x0d
     c60:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     c62:	6b 85       	ldd	r22, Y+11	; 0x0b
     c64:	7c 85       	ldd	r23, Y+12	; 0x0c
     c66:	8d 85       	ldd	r24, Y+13	; 0x0d
     c68:	9e 85       	ldd	r25, Y+14	; 0x0e
     c6a:	20 e0       	ldi	r18, 0x00	; 0
     c6c:	30 e0       	ldi	r19, 0x00	; 0
     c6e:	4a ef       	ldi	r20, 0xFA	; 250
     c70:	54 e4       	ldi	r21, 0x44	; 68
     c72:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     c76:	dc 01       	movw	r26, r24
     c78:	cb 01       	movw	r24, r22
     c7a:	8f 83       	std	Y+7, r24	; 0x07
     c7c:	98 87       	std	Y+8, r25	; 0x08
     c7e:	a9 87       	std	Y+9, r26	; 0x09
     c80:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
     c82:	6f 81       	ldd	r22, Y+7	; 0x07
     c84:	78 85       	ldd	r23, Y+8	; 0x08
     c86:	89 85       	ldd	r24, Y+9	; 0x09
     c88:	9a 85       	ldd	r25, Y+10	; 0x0a
     c8a:	20 e0       	ldi	r18, 0x00	; 0
     c8c:	30 e0       	ldi	r19, 0x00	; 0
     c8e:	40 e8       	ldi	r20, 0x80	; 128
     c90:	5f e3       	ldi	r21, 0x3F	; 63
     c92:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     c96:	88 23       	and	r24, r24
     c98:	2c f4       	brge	.+10     	; 0xca4 <check_created_password+0x10c>
		__ticks = 1;
     c9a:	81 e0       	ldi	r24, 0x01	; 1
     c9c:	90 e0       	ldi	r25, 0x00	; 0
     c9e:	9e 83       	std	Y+6, r25	; 0x06
     ca0:	8d 83       	std	Y+5, r24	; 0x05
     ca2:	3f c0       	rjmp	.+126    	; 0xd22 <check_created_password+0x18a>
	else if (__tmp > 65535)
     ca4:	6f 81       	ldd	r22, Y+7	; 0x07
     ca6:	78 85       	ldd	r23, Y+8	; 0x08
     ca8:	89 85       	ldd	r24, Y+9	; 0x09
     caa:	9a 85       	ldd	r25, Y+10	; 0x0a
     cac:	20 e0       	ldi	r18, 0x00	; 0
     cae:	3f ef       	ldi	r19, 0xFF	; 255
     cb0:	4f e7       	ldi	r20, 0x7F	; 127
     cb2:	57 e4       	ldi	r21, 0x47	; 71
     cb4:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
     cb8:	18 16       	cp	r1, r24
     cba:	4c f5       	brge	.+82     	; 0xd0e <check_created_password+0x176>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     cbc:	6b 85       	ldd	r22, Y+11	; 0x0b
     cbe:	7c 85       	ldd	r23, Y+12	; 0x0c
     cc0:	8d 85       	ldd	r24, Y+13	; 0x0d
     cc2:	9e 85       	ldd	r25, Y+14	; 0x0e
     cc4:	20 e0       	ldi	r18, 0x00	; 0
     cc6:	30 e0       	ldi	r19, 0x00	; 0
     cc8:	40 e2       	ldi	r20, 0x20	; 32
     cca:	51 e4       	ldi	r21, 0x41	; 65
     ccc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     cd0:	dc 01       	movw	r26, r24
     cd2:	cb 01       	movw	r24, r22
     cd4:	bc 01       	movw	r22, r24
     cd6:	cd 01       	movw	r24, r26
     cd8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     cdc:	dc 01       	movw	r26, r24
     cde:	cb 01       	movw	r24, r22
     ce0:	9e 83       	std	Y+6, r25	; 0x06
     ce2:	8d 83       	std	Y+5, r24	; 0x05
     ce4:	0f c0       	rjmp	.+30     	; 0xd04 <check_created_password+0x16c>
     ce6:	88 ec       	ldi	r24, 0xC8	; 200
     ce8:	90 e0       	ldi	r25, 0x00	; 0
     cea:	9c 83       	std	Y+4, r25	; 0x04
     cec:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     cee:	8b 81       	ldd	r24, Y+3	; 0x03
     cf0:	9c 81       	ldd	r25, Y+4	; 0x04
     cf2:	01 97       	sbiw	r24, 0x01	; 1
     cf4:	f1 f7       	brne	.-4      	; 0xcf2 <check_created_password+0x15a>
     cf6:	9c 83       	std	Y+4, r25	; 0x04
     cf8:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     cfa:	8d 81       	ldd	r24, Y+5	; 0x05
     cfc:	9e 81       	ldd	r25, Y+6	; 0x06
     cfe:	01 97       	sbiw	r24, 0x01	; 1
     d00:	9e 83       	std	Y+6, r25	; 0x06
     d02:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     d04:	8d 81       	ldd	r24, Y+5	; 0x05
     d06:	9e 81       	ldd	r25, Y+6	; 0x06
     d08:	00 97       	sbiw	r24, 0x00	; 0
     d0a:	69 f7       	brne	.-38     	; 0xce6 <check_created_password+0x14e>
     d0c:	14 c0       	rjmp	.+40     	; 0xd36 <check_created_password+0x19e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     d0e:	6f 81       	ldd	r22, Y+7	; 0x07
     d10:	78 85       	ldd	r23, Y+8	; 0x08
     d12:	89 85       	ldd	r24, Y+9	; 0x09
     d14:	9a 85       	ldd	r25, Y+10	; 0x0a
     d16:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     d1a:	dc 01       	movw	r26, r24
     d1c:	cb 01       	movw	r24, r22
     d1e:	9e 83       	std	Y+6, r25	; 0x06
     d20:	8d 83       	std	Y+5, r24	; 0x05
     d22:	8d 81       	ldd	r24, Y+5	; 0x05
     d24:	9e 81       	ldd	r25, Y+6	; 0x06
     d26:	9a 83       	std	Y+2, r25	; 0x02
     d28:	89 83       	std	Y+1, r24	; 0x01
     d2a:	89 81       	ldd	r24, Y+1	; 0x01
     d2c:	9a 81       	ldd	r25, Y+2	; 0x02
     d2e:	01 97       	sbiw	r24, 0x01	; 1
     d30:	f1 f7       	brne	.-4      	; 0xd2e <check_created_password+0x196>
     d32:	9a 83       	std	Y+2, r25	; 0x02
     d34:	89 83       	std	Y+1, r24	; 0x01
			_delay_ms(30);//for EEPROM
			/*******************************************/
			MAIN_options_control();/**step2**/
     d36:	0e 94 b6 06 	call	0xd6c	; 0xd6c <MAIN_options_control>
     d3a:	0d c0       	rjmp	.+26     	; 0xd56 <check_created_password+0x1be>
			}
		else if(pass_missmatch!=0)//match bet it and the saved pass in EEPROM
     d3c:	8f 85       	ldd	r24, Y+15	; 0x0f
     d3e:	88 23       	and	r24, r24
     d40:	51 f0       	breq	.+20     	; 0xd56 <check_created_password+0x1be>
			{
			UART_sendByte(PASSWORD_CHECKING_FINISHED);/**second time:checking**/
     d42:	82 e1       	ldi	r24, 0x12	; 18
     d44:	0e 94 b1 11 	call	0x2362	; 0x2362 <UART_sendByte>
			UART_sendByte(PASSWORDS_DONT_MATCH);/**second time: don't match **/
     d48:	84 e1       	ldi	r24, 0x14	; 20
     d4a:	0e 94 b1 11 	call	0x2362	; 0x2362 <UART_sendByte>
			check_created_password(retry_pass_control);/**step1 again**/
     d4e:	ce 01       	movw	r24, r28
     d50:	47 96       	adiw	r24, 0x17	; 23
     d52:	0e 94 cc 05 	call	0xb98	; 0xb98 <check_created_password>
			}

}
     d56:	6d 96       	adiw	r28, 0x1d	; 29
     d58:	0f b6       	in	r0, 0x3f	; 63
     d5a:	f8 94       	cli
     d5c:	de bf       	out	0x3e, r29	; 62
     d5e:	0f be       	out	0x3f, r0	; 63
     d60:	cd bf       	out	0x3d, r28	; 61
     d62:	cf 91       	pop	r28
     d64:	df 91       	pop	r29
     d66:	1f 91       	pop	r17
     d68:	0f 91       	pop	r16
     d6a:	08 95       	ret

00000d6c <MAIN_options_control>:
/********************************************************************************/
void MAIN_options_control(){/**step2**/
     d6c:	df 93       	push	r29
     d6e:	cf 93       	push	r28
     d70:	0f 92       	push	r0
     d72:	cd b7       	in	r28, 0x3d	; 61
     d74:	de b7       	in	r29, 0x3e	; 62
   uint8 chosen_option;//define what option is chosen on MC1
	while(UART_recieveByte() != OPTION_MENU);/**THIRD time :be ready for option menu**/
     d76:	0e 94 c8 11 	call	0x2390	; 0x2390 <UART_recieveByte>
     d7a:	85 31       	cpi	r24, 0x15	; 21
     d7c:	e1 f7       	brne	.-8      	; 0xd76 <MAIN_options_control+0xa>
	chosen_option=UART_recieveByte();/**THIRD time**/
     d7e:	0e 94 c8 11 	call	0x2390	; 0x2390 <UART_recieveByte>
     d82:	89 83       	std	Y+1, r24	; 0x01
	if(chosen_option == OPEN_DOOR)/**THIRD time :1)open door**/
     d84:	89 81       	ldd	r24, Y+1	; 0x01
     d86:	86 31       	cpi	r24, 0x16	; 22
     d88:	11 f4       	brne	.+4      	; 0xd8e <MAIN_options_control+0x22>
		{
		control_open_door();/**step3**/
     d8a:	0e 94 ff 06 	call	0xdfe	; 0xdfe <control_open_door>
		}
	if(chosen_option == CHANGE_PASS)/**THIRD time :2)change pass**/
     d8e:	89 81       	ldd	r24, Y+1	; 0x01
     d90:	80 32       	cpi	r24, 0x20	; 32
     d92:	11 f4       	brne	.+4      	; 0xd98 <MAIN_options_control+0x2c>
		{
		control_change_password();/**step4**/
     d94:	0e 94 54 08 	call	0x10a8	; 0x10a8 <control_change_password>
		}
}
     d98:	0f 90       	pop	r0
     d9a:	cf 91       	pop	r28
     d9c:	df 91       	pop	r29
     d9e:	08 95       	ret

00000da0 <receive_user_entered_pass>:
/********************************************************************************/
void receive_user_entered_pass(uint8 *user_entered_password){/** for  step1 & step3 & step4**/
     da0:	0f 93       	push	r16
     da2:	1f 93       	push	r17
     da4:	df 93       	push	r29
     da6:	cf 93       	push	r28
     da8:	00 d0       	rcall	.+0      	; 0xdaa <receive_user_entered_pass+0xa>
     daa:	0f 92       	push	r0
     dac:	cd b7       	in	r28, 0x3d	; 61
     dae:	de b7       	in	r29, 0x3e	; 62
     db0:	9b 83       	std	Y+3, r25	; 0x03
     db2:	8a 83       	std	Y+2, r24	; 0x02
	uint8 enter_counter=0;
     db4:	19 82       	std	Y+1, r1	; 0x01

	while(UART_recieveByte() !=USER_ENTERED_PASS);/**FOURTH time -> be ready for the the entered pass**/
     db6:	0e 94 c8 11 	call	0x2390	; 0x2390 <UART_recieveByte>
     dba:	87 31       	cpi	r24, 0x17	; 23
     dbc:	e1 f7       	brne	.-8      	; 0xdb6 <receive_user_entered_pass+0x16>
	for(enter_counter=0;enter_counter<(password_length);enter_counter++)
     dbe:	19 82       	std	Y+1, r1	; 0x01
     dc0:	13 c0       	rjmp	.+38     	; 0xde8 <receive_user_entered_pass+0x48>
	{
		while(UART_recieveByte() !=USER_ENTERED_PASS);/**FOURTH time -> be ready for the the entered pass**/
     dc2:	0e 94 c8 11 	call	0x2390	; 0x2390 <UART_recieveByte>
     dc6:	87 31       	cpi	r24, 0x17	; 23
     dc8:	e1 f7       	brne	.-8      	; 0xdc2 <receive_user_entered_pass+0x22>
		user_entered_password[enter_counter] = UART_recieveByte();//Receive the entered pass
     dca:	89 81       	ldd	r24, Y+1	; 0x01
     dcc:	28 2f       	mov	r18, r24
     dce:	30 e0       	ldi	r19, 0x00	; 0
     dd0:	8a 81       	ldd	r24, Y+2	; 0x02
     dd2:	9b 81       	ldd	r25, Y+3	; 0x03
     dd4:	8c 01       	movw	r16, r24
     dd6:	02 0f       	add	r16, r18
     dd8:	13 1f       	adc	r17, r19
     dda:	0e 94 c8 11 	call	0x2390	; 0x2390 <UART_recieveByte>
     dde:	f8 01       	movw	r30, r16
     de0:	80 83       	st	Z, r24
/********************************************************************************/
void receive_user_entered_pass(uint8 *user_entered_password){/** for  step1 & step3 & step4**/
	uint8 enter_counter=0;

	while(UART_recieveByte() !=USER_ENTERED_PASS);/**FOURTH time -> be ready for the the entered pass**/
	for(enter_counter=0;enter_counter<(password_length);enter_counter++)
     de2:	89 81       	ldd	r24, Y+1	; 0x01
     de4:	8f 5f       	subi	r24, 0xFF	; 255
     de6:	89 83       	std	Y+1, r24	; 0x01
     de8:	89 81       	ldd	r24, Y+1	; 0x01
     dea:	85 30       	cpi	r24, 0x05	; 5
     dec:	50 f3       	brcs	.-44     	; 0xdc2 <receive_user_entered_pass+0x22>
	{
		while(UART_recieveByte() !=USER_ENTERED_PASS);/**FOURTH time -> be ready for the the entered pass**/
		user_entered_password[enter_counter] = UART_recieveByte();//Receive the entered pass
	}
}
     dee:	0f 90       	pop	r0
     df0:	0f 90       	pop	r0
     df2:	0f 90       	pop	r0
     df4:	cf 91       	pop	r28
     df6:	df 91       	pop	r29
     df8:	1f 91       	pop	r17
     dfa:	0f 91       	pop	r16
     dfc:	08 95       	ret

00000dfe <control_open_door>:
/********************************************************************************/
void control_open_door(){/**step3**/
     dfe:	df 93       	push	r29
     e00:	cf 93       	push	r28
     e02:	cd b7       	in	r28, 0x3d	; 61
     e04:	de b7       	in	r29, 0x3e	; 62
     e06:	a3 97       	sbiw	r28, 0x23	; 35
     e08:	0f b6       	in	r0, 0x3f	; 63
     e0a:	f8 94       	cli
     e0c:	de bf       	out	0x3e, r29	; 62
     e0e:	0f be       	out	0x3f, r0	; 63
     e10:	cd bf       	out	0x3d, r28	; 61
	uint8 door_counter;
	uint8 door_miss_match=0;
     e12:	1d 8e       	std	Y+29, r1	; 0x1d
	uint8 pass_door_control[password_length];

	receive_user_entered_pass(pass_door_control);
     e14:	ce 01       	movw	r24, r28
     e16:	4f 96       	adiw	r24, 0x1f	; 31
     e18:	0e 94 d0 06 	call	0xda0	; 0xda0 <receive_user_entered_pass>

	Get_pass_inside_EEEPROM(pass_in_EEPROM);
     e1c:	81 e7       	ldi	r24, 0x71	; 113
     e1e:	90 e0       	ldi	r25, 0x00	; 0
     e20:	0e 94 de 09 	call	0x13bc	; 0x13bc <Get_pass_inside_EEEPROM>
	/********** MC2 Response *************/
	for(door_counter=0;door_counter<(password_length);door_counter++)
     e24:	1e 8e       	std	Y+30, r1	; 0x1e
     e26:	19 c0       	rjmp	.+50     	; 0xe5a <control_open_door+0x5c>
	{
		if(pass_door_control[door_counter]!=pass_in_EEPROM[door_counter])
     e28:	8e 8d       	ldd	r24, Y+30	; 0x1e
     e2a:	28 2f       	mov	r18, r24
     e2c:	30 e0       	ldi	r19, 0x00	; 0
     e2e:	ce 01       	movw	r24, r28
     e30:	4f 96       	adiw	r24, 0x1f	; 31
     e32:	fc 01       	movw	r30, r24
     e34:	e2 0f       	add	r30, r18
     e36:	f3 1f       	adc	r31, r19
     e38:	20 81       	ld	r18, Z
     e3a:	8e 8d       	ldd	r24, Y+30	; 0x1e
     e3c:	88 2f       	mov	r24, r24
     e3e:	90 e0       	ldi	r25, 0x00	; 0
     e40:	fc 01       	movw	r30, r24
     e42:	ef 58       	subi	r30, 0x8F	; 143
     e44:	ff 4f       	sbci	r31, 0xFF	; 255
     e46:	80 81       	ld	r24, Z
     e48:	28 17       	cp	r18, r24
     e4a:	21 f0       	breq	.+8      	; 0xe54 <control_open_door+0x56>
			{
			door_miss_match++;
     e4c:	8d 8d       	ldd	r24, Y+29	; 0x1d
     e4e:	8f 5f       	subi	r24, 0xFF	; 255
     e50:	8d 8f       	std	Y+29, r24	; 0x1d
     e52:	06 c0       	rjmp	.+12     	; 0xe60 <control_open_door+0x62>

	receive_user_entered_pass(pass_door_control);

	Get_pass_inside_EEEPROM(pass_in_EEPROM);
	/********** MC2 Response *************/
	for(door_counter=0;door_counter<(password_length);door_counter++)
     e54:	8e 8d       	ldd	r24, Y+30	; 0x1e
     e56:	8f 5f       	subi	r24, 0xFF	; 255
     e58:	8e 8f       	std	Y+30, r24	; 0x1e
     e5a:	8e 8d       	ldd	r24, Y+30	; 0x1e
     e5c:	85 30       	cpi	r24, 0x05	; 5
     e5e:	20 f3       	brcs	.-56     	; 0xe28 <control_open_door+0x2a>
			door_miss_match++;
			break;//no need to compare further
			}
	}

	UART_sendByte(USER_ACCESS);
     e60:	88 e1       	ldi	r24, 0x18	; 24
     e62:	0e 94 b1 11 	call	0x2362	; 0x2362 <UART_sendByte>
	if(door_miss_match==0)//PASS match bet it and the saved pass in EEPROM
     e66:	8d 8d       	ldd	r24, Y+29	; 0x1d
     e68:	88 23       	and	r24, r24
     e6a:	99 f4       	brne	.+38     	; 0xe92 <control_open_door+0x94>
	{
		UART_sendByte(PASSWORDS_IS_CORRECT);/**FIFTH time **/
     e6c:	89 e1       	ldi	r24, 0x19	; 25
     e6e:	0e 94 b1 11 	call	0x2362	; 0x2362 <UART_sendByte>
		if(	locking_door==0)
     e72:	80 91 78 00 	lds	r24, 0x0078
     e76:	88 23       	and	r24, r24
     e78:	21 f4       	brne	.+8      	; 0xe82 <control_open_door+0x84>
		{
			DcMotor_Rotate(MOTOR_CW, 100);/**DOOR UNLOCKING FOR 15 SEC**/
     e7a:	81 e0       	ldi	r24, 0x01	; 1
     e7c:	64 e6       	ldi	r22, 0x64	; 100
     e7e:	0e 94 1b 10 	call	0x2036	; 0x2036 <DcMotor_Rotate>
		}
		if (timer1_is_init == 0)/**START timer1 for 15sec*/
     e82:	80 91 77 00 	lds	r24, 0x0077
     e86:	88 23       	and	r24, r24
     e88:	09 f0       	breq	.+2      	; 0xe8c <control_open_door+0x8e>
     e8a:	05 c1       	rjmp	.+522    	; 0x1096 <control_open_door+0x298>
		{
			Start_DcMotor_TIMER1();//timer1_is_init is now =1
     e8c:	0e 94 58 10 	call	0x20b0	; 0x20b0 <Start_DcMotor_TIMER1>
     e90:	02 c1       	rjmp	.+516    	; 0x1096 <control_open_door+0x298>
		}
		/**the process of locking the door and holding it happens after 15sec
		 * when Timer1 calls DcMotor_timer_finished IN MOTOR DRIVER
		 * */
	}
	else if (door_miss_match!=0)
     e92:	8d 8d       	ldd	r24, Y+29	; 0x1d
     e94:	88 23       	and	r24, r24
     e96:	09 f4       	brne	.+2      	; 0xe9a <control_open_door+0x9c>
     e98:	fe c0       	rjmp	.+508    	; 0x1096 <control_open_door+0x298>
	{
		counter_for_buzzer++;
     e9a:	80 91 80 00 	lds	r24, 0x0080
     e9e:	8f 5f       	subi	r24, 0xFF	; 255
     ea0:	80 93 80 00 	sts	0x0080, r24
		UART_sendByte(PASSWORDS_DONT_MATCH);
     ea4:	84 e1       	ldi	r24, 0x14	; 20
     ea6:	0e 94 b1 11 	call	0x2362	; 0x2362 <UART_sendByte>
		if(counter_for_buzzer==3)
     eaa:	80 91 80 00 	lds	r24, 0x0080
     eae:	83 30       	cpi	r24, 0x03	; 3
     eb0:	09 f0       	breq	.+2      	; 0xeb4 <control_open_door+0xb6>
     eb2:	ef c0       	rjmp	.+478    	; 0x1092 <control_open_door+0x294>
		   {
			  	  /********ACTIVATE ALARM*********/
			  Buzzer_on();//BUZZZER ON
     eb4:	0e 94 b4 05 	call	0xb68	; 0xb68 <Buzzer_on>
     eb8:	80 e0       	ldi	r24, 0x00	; 0
     eba:	90 e6       	ldi	r25, 0x60	; 96
     ebc:	aa ee       	ldi	r26, 0xEA	; 234
     ebe:	b6 e4       	ldi	r27, 0x46	; 70
     ec0:	89 8f       	std	Y+25, r24	; 0x19
     ec2:	9a 8f       	std	Y+26, r25	; 0x1a
     ec4:	ab 8f       	std	Y+27, r26	; 0x1b
     ec6:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     ec8:	69 8d       	ldd	r22, Y+25	; 0x19
     eca:	7a 8d       	ldd	r23, Y+26	; 0x1a
     ecc:	8b 8d       	ldd	r24, Y+27	; 0x1b
     ece:	9c 8d       	ldd	r25, Y+28	; 0x1c
     ed0:	20 e0       	ldi	r18, 0x00	; 0
     ed2:	30 e0       	ldi	r19, 0x00	; 0
     ed4:	4a ef       	ldi	r20, 0xFA	; 250
     ed6:	54 e4       	ldi	r21, 0x44	; 68
     ed8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     edc:	dc 01       	movw	r26, r24
     ede:	cb 01       	movw	r24, r22
     ee0:	8d 8b       	std	Y+21, r24	; 0x15
     ee2:	9e 8b       	std	Y+22, r25	; 0x16
     ee4:	af 8b       	std	Y+23, r26	; 0x17
     ee6:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
     ee8:	6d 89       	ldd	r22, Y+21	; 0x15
     eea:	7e 89       	ldd	r23, Y+22	; 0x16
     eec:	8f 89       	ldd	r24, Y+23	; 0x17
     eee:	98 8d       	ldd	r25, Y+24	; 0x18
     ef0:	20 e0       	ldi	r18, 0x00	; 0
     ef2:	30 e0       	ldi	r19, 0x00	; 0
     ef4:	40 e8       	ldi	r20, 0x80	; 128
     ef6:	5f e3       	ldi	r21, 0x3F	; 63
     ef8:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     efc:	88 23       	and	r24, r24
     efe:	2c f4       	brge	.+10     	; 0xf0a <control_open_door+0x10c>
		__ticks = 1;
     f00:	81 e0       	ldi	r24, 0x01	; 1
     f02:	90 e0       	ldi	r25, 0x00	; 0
     f04:	9c 8b       	std	Y+20, r25	; 0x14
     f06:	8b 8b       	std	Y+19, r24	; 0x13
     f08:	3f c0       	rjmp	.+126    	; 0xf88 <control_open_door+0x18a>
	else if (__tmp > 65535)
     f0a:	6d 89       	ldd	r22, Y+21	; 0x15
     f0c:	7e 89       	ldd	r23, Y+22	; 0x16
     f0e:	8f 89       	ldd	r24, Y+23	; 0x17
     f10:	98 8d       	ldd	r25, Y+24	; 0x18
     f12:	20 e0       	ldi	r18, 0x00	; 0
     f14:	3f ef       	ldi	r19, 0xFF	; 255
     f16:	4f e7       	ldi	r20, 0x7F	; 127
     f18:	57 e4       	ldi	r21, 0x47	; 71
     f1a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
     f1e:	18 16       	cp	r1, r24
     f20:	4c f5       	brge	.+82     	; 0xf74 <control_open_door+0x176>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     f22:	69 8d       	ldd	r22, Y+25	; 0x19
     f24:	7a 8d       	ldd	r23, Y+26	; 0x1a
     f26:	8b 8d       	ldd	r24, Y+27	; 0x1b
     f28:	9c 8d       	ldd	r25, Y+28	; 0x1c
     f2a:	20 e0       	ldi	r18, 0x00	; 0
     f2c:	30 e0       	ldi	r19, 0x00	; 0
     f2e:	40 e2       	ldi	r20, 0x20	; 32
     f30:	51 e4       	ldi	r21, 0x41	; 65
     f32:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     f36:	dc 01       	movw	r26, r24
     f38:	cb 01       	movw	r24, r22
     f3a:	bc 01       	movw	r22, r24
     f3c:	cd 01       	movw	r24, r26
     f3e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     f42:	dc 01       	movw	r26, r24
     f44:	cb 01       	movw	r24, r22
     f46:	9c 8b       	std	Y+20, r25	; 0x14
     f48:	8b 8b       	std	Y+19, r24	; 0x13
     f4a:	0f c0       	rjmp	.+30     	; 0xf6a <control_open_door+0x16c>
     f4c:	88 ec       	ldi	r24, 0xC8	; 200
     f4e:	90 e0       	ldi	r25, 0x00	; 0
     f50:	9a 8b       	std	Y+18, r25	; 0x12
     f52:	89 8b       	std	Y+17, r24	; 0x11
     f54:	89 89       	ldd	r24, Y+17	; 0x11
     f56:	9a 89       	ldd	r25, Y+18	; 0x12
     f58:	01 97       	sbiw	r24, 0x01	; 1
     f5a:	f1 f7       	brne	.-4      	; 0xf58 <control_open_door+0x15a>
     f5c:	9a 8b       	std	Y+18, r25	; 0x12
     f5e:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     f60:	8b 89       	ldd	r24, Y+19	; 0x13
     f62:	9c 89       	ldd	r25, Y+20	; 0x14
     f64:	01 97       	sbiw	r24, 0x01	; 1
     f66:	9c 8b       	std	Y+20, r25	; 0x14
     f68:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     f6a:	8b 89       	ldd	r24, Y+19	; 0x13
     f6c:	9c 89       	ldd	r25, Y+20	; 0x14
     f6e:	00 97       	sbiw	r24, 0x00	; 0
     f70:	69 f7       	brne	.-38     	; 0xf4c <control_open_door+0x14e>
     f72:	14 c0       	rjmp	.+40     	; 0xf9c <control_open_door+0x19e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     f74:	6d 89       	ldd	r22, Y+21	; 0x15
     f76:	7e 89       	ldd	r23, Y+22	; 0x16
     f78:	8f 89       	ldd	r24, Y+23	; 0x17
     f7a:	98 8d       	ldd	r25, Y+24	; 0x18
     f7c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     f80:	dc 01       	movw	r26, r24
     f82:	cb 01       	movw	r24, r22
     f84:	9c 8b       	std	Y+20, r25	; 0x14
     f86:	8b 8b       	std	Y+19, r24	; 0x13
     f88:	8b 89       	ldd	r24, Y+19	; 0x13
     f8a:	9c 89       	ldd	r25, Y+20	; 0x14
     f8c:	98 8b       	std	Y+16, r25	; 0x10
     f8e:	8f 87       	std	Y+15, r24	; 0x0f
     f90:	8f 85       	ldd	r24, Y+15	; 0x0f
     f92:	98 89       	ldd	r25, Y+16	; 0x10
     f94:	01 97       	sbiw	r24, 0x01	; 1
     f96:	f1 f7       	brne	.-4      	; 0xf94 <control_open_door+0x196>
     f98:	98 8b       	std	Y+16, r25	; 0x10
     f9a:	8f 87       	std	Y+15, r24	; 0x0f
     f9c:	80 e0       	ldi	r24, 0x00	; 0
     f9e:	90 e6       	ldi	r25, 0x60	; 96
     fa0:	aa ee       	ldi	r26, 0xEA	; 234
     fa2:	b6 e4       	ldi	r27, 0x46	; 70
     fa4:	8b 87       	std	Y+11, r24	; 0x0b
     fa6:	9c 87       	std	Y+12, r25	; 0x0c
     fa8:	ad 87       	std	Y+13, r26	; 0x0d
     faa:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     fac:	6b 85       	ldd	r22, Y+11	; 0x0b
     fae:	7c 85       	ldd	r23, Y+12	; 0x0c
     fb0:	8d 85       	ldd	r24, Y+13	; 0x0d
     fb2:	9e 85       	ldd	r25, Y+14	; 0x0e
     fb4:	20 e0       	ldi	r18, 0x00	; 0
     fb6:	30 e0       	ldi	r19, 0x00	; 0
     fb8:	4a ef       	ldi	r20, 0xFA	; 250
     fba:	54 e4       	ldi	r21, 0x44	; 68
     fbc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     fc0:	dc 01       	movw	r26, r24
     fc2:	cb 01       	movw	r24, r22
     fc4:	8f 83       	std	Y+7, r24	; 0x07
     fc6:	98 87       	std	Y+8, r25	; 0x08
     fc8:	a9 87       	std	Y+9, r26	; 0x09
     fca:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
     fcc:	6f 81       	ldd	r22, Y+7	; 0x07
     fce:	78 85       	ldd	r23, Y+8	; 0x08
     fd0:	89 85       	ldd	r24, Y+9	; 0x09
     fd2:	9a 85       	ldd	r25, Y+10	; 0x0a
     fd4:	20 e0       	ldi	r18, 0x00	; 0
     fd6:	30 e0       	ldi	r19, 0x00	; 0
     fd8:	40 e8       	ldi	r20, 0x80	; 128
     fda:	5f e3       	ldi	r21, 0x3F	; 63
     fdc:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     fe0:	88 23       	and	r24, r24
     fe2:	2c f4       	brge	.+10     	; 0xfee <control_open_door+0x1f0>
		__ticks = 1;
     fe4:	81 e0       	ldi	r24, 0x01	; 1
     fe6:	90 e0       	ldi	r25, 0x00	; 0
     fe8:	9e 83       	std	Y+6, r25	; 0x06
     fea:	8d 83       	std	Y+5, r24	; 0x05
     fec:	3f c0       	rjmp	.+126    	; 0x106c <control_open_door+0x26e>
	else if (__tmp > 65535)
     fee:	6f 81       	ldd	r22, Y+7	; 0x07
     ff0:	78 85       	ldd	r23, Y+8	; 0x08
     ff2:	89 85       	ldd	r24, Y+9	; 0x09
     ff4:	9a 85       	ldd	r25, Y+10	; 0x0a
     ff6:	20 e0       	ldi	r18, 0x00	; 0
     ff8:	3f ef       	ldi	r19, 0xFF	; 255
     ffa:	4f e7       	ldi	r20, 0x7F	; 127
     ffc:	57 e4       	ldi	r21, 0x47	; 71
     ffe:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1002:	18 16       	cp	r1, r24
    1004:	4c f5       	brge	.+82     	; 0x1058 <control_open_door+0x25a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1006:	6b 85       	ldd	r22, Y+11	; 0x0b
    1008:	7c 85       	ldd	r23, Y+12	; 0x0c
    100a:	8d 85       	ldd	r24, Y+13	; 0x0d
    100c:	9e 85       	ldd	r25, Y+14	; 0x0e
    100e:	20 e0       	ldi	r18, 0x00	; 0
    1010:	30 e0       	ldi	r19, 0x00	; 0
    1012:	40 e2       	ldi	r20, 0x20	; 32
    1014:	51 e4       	ldi	r21, 0x41	; 65
    1016:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    101a:	dc 01       	movw	r26, r24
    101c:	cb 01       	movw	r24, r22
    101e:	bc 01       	movw	r22, r24
    1020:	cd 01       	movw	r24, r26
    1022:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1026:	dc 01       	movw	r26, r24
    1028:	cb 01       	movw	r24, r22
    102a:	9e 83       	std	Y+6, r25	; 0x06
    102c:	8d 83       	std	Y+5, r24	; 0x05
    102e:	0f c0       	rjmp	.+30     	; 0x104e <control_open_door+0x250>
    1030:	88 ec       	ldi	r24, 0xC8	; 200
    1032:	90 e0       	ldi	r25, 0x00	; 0
    1034:	9c 83       	std	Y+4, r25	; 0x04
    1036:	8b 83       	std	Y+3, r24	; 0x03
    1038:	8b 81       	ldd	r24, Y+3	; 0x03
    103a:	9c 81       	ldd	r25, Y+4	; 0x04
    103c:	01 97       	sbiw	r24, 0x01	; 1
    103e:	f1 f7       	brne	.-4      	; 0x103c <control_open_door+0x23e>
    1040:	9c 83       	std	Y+4, r25	; 0x04
    1042:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1044:	8d 81       	ldd	r24, Y+5	; 0x05
    1046:	9e 81       	ldd	r25, Y+6	; 0x06
    1048:	01 97       	sbiw	r24, 0x01	; 1
    104a:	9e 83       	std	Y+6, r25	; 0x06
    104c:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    104e:	8d 81       	ldd	r24, Y+5	; 0x05
    1050:	9e 81       	ldd	r25, Y+6	; 0x06
    1052:	00 97       	sbiw	r24, 0x00	; 0
    1054:	69 f7       	brne	.-38     	; 0x1030 <control_open_door+0x232>
    1056:	14 c0       	rjmp	.+40     	; 0x1080 <control_open_door+0x282>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1058:	6f 81       	ldd	r22, Y+7	; 0x07
    105a:	78 85       	ldd	r23, Y+8	; 0x08
    105c:	89 85       	ldd	r24, Y+9	; 0x09
    105e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1060:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1064:	dc 01       	movw	r26, r24
    1066:	cb 01       	movw	r24, r22
    1068:	9e 83       	std	Y+6, r25	; 0x06
    106a:	8d 83       	std	Y+5, r24	; 0x05
    106c:	8d 81       	ldd	r24, Y+5	; 0x05
    106e:	9e 81       	ldd	r25, Y+6	; 0x06
    1070:	9a 83       	std	Y+2, r25	; 0x02
    1072:	89 83       	std	Y+1, r24	; 0x01
    1074:	89 81       	ldd	r24, Y+1	; 0x01
    1076:	9a 81       	ldd	r25, Y+2	; 0x02
    1078:	01 97       	sbiw	r24, 0x01	; 1
    107a:	f1 f7       	brne	.-4      	; 0x1078 <control_open_door+0x27a>
    107c:	9a 83       	std	Y+2, r25	; 0x02
    107e:	89 83       	std	Y+1, r24	; 0x01
			  _delay_ms(30000);//keep Buzzer ON for  1 minute
			  _delay_ms(30000);
			  UART_sendByte(UNBLOCK_THE_SYSTEM);
    1080:	81 e2       	ldi	r24, 0x21	; 33
    1082:	0e 94 b1 11 	call	0x2362	; 0x2362 <UART_sendByte>
			  counter_for_buzzer=0;//so i cna count again
    1086:	10 92 80 00 	sts	0x0080, r1
			  Buzzer_off();
    108a:	0e 94 c0 05 	call	0xb80	; 0xb80 <Buzzer_off>
			  MAIN_options_control();/** back to step2**/
    108e:	0e 94 b6 06 	call	0xd6c	; 0xd6c <MAIN_options_control>
		   }
		control_open_door();
    1092:	0e 94 ff 06 	call	0xdfe	; 0xdfe <control_open_door>
	}

}
    1096:	a3 96       	adiw	r28, 0x23	; 35
    1098:	0f b6       	in	r0, 0x3f	; 63
    109a:	f8 94       	cli
    109c:	de bf       	out	0x3e, r29	; 62
    109e:	0f be       	out	0x3f, r0	; 63
    10a0:	cd bf       	out	0x3d, r28	; 61
    10a2:	cf 91       	pop	r28
    10a4:	df 91       	pop	r29
    10a6:	08 95       	ret

000010a8 <control_change_password>:
/********************************************************************************/
void control_change_password(){/**step4**/
    10a8:	df 93       	push	r29
    10aa:	cf 93       	push	r28
    10ac:	cd b7       	in	r28, 0x3d	; 61
    10ae:	de b7       	in	r29, 0x3e	; 62
    10b0:	a8 97       	sbiw	r28, 0x28	; 40
    10b2:	0f b6       	in	r0, 0x3f	; 63
    10b4:	f8 94       	cli
    10b6:	de bf       	out	0x3e, r29	; 62
    10b8:	0f be       	out	0x3f, r0	; 63
    10ba:	cd bf       	out	0x3d, r28	; 61
	uint8 chg_counter;
	uint8 chg_miss_match=0;
    10bc:	1d 8e       	std	Y+29, r1	; 0x1d
	uint8 pass_chg_control[password_length];

	uint8 new_sys_pass[password_length];

	Get_pass_inside_EEEPROM(pass_in_EEPROM);
    10be:	81 e7       	ldi	r24, 0x71	; 113
    10c0:	90 e0       	ldi	r25, 0x00	; 0
    10c2:	0e 94 de 09 	call	0x13bc	; 0x13bc <Get_pass_inside_EEEPROM>
	receive_user_entered_pass(pass_chg_control);
    10c6:	ce 01       	movw	r24, r28
    10c8:	4f 96       	adiw	r24, 0x1f	; 31
    10ca:	0e 94 d0 06 	call	0xda0	; 0xda0 <receive_user_entered_pass>

	/********** MC2 Response *************/
		for(chg_counter=0;chg_counter<(password_length);chg_counter++)
    10ce:	1e 8e       	std	Y+30, r1	; 0x1e
    10d0:	19 c0       	rjmp	.+50     	; 0x1104 <control_change_password+0x5c>
		{
			if(pass_chg_control[chg_counter]!=pass_in_EEPROM[chg_counter])
    10d2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    10d4:	28 2f       	mov	r18, r24
    10d6:	30 e0       	ldi	r19, 0x00	; 0
    10d8:	ce 01       	movw	r24, r28
    10da:	4f 96       	adiw	r24, 0x1f	; 31
    10dc:	fc 01       	movw	r30, r24
    10de:	e2 0f       	add	r30, r18
    10e0:	f3 1f       	adc	r31, r19
    10e2:	20 81       	ld	r18, Z
    10e4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    10e6:	88 2f       	mov	r24, r24
    10e8:	90 e0       	ldi	r25, 0x00	; 0
    10ea:	fc 01       	movw	r30, r24
    10ec:	ef 58       	subi	r30, 0x8F	; 143
    10ee:	ff 4f       	sbci	r31, 0xFF	; 255
    10f0:	80 81       	ld	r24, Z
    10f2:	28 17       	cp	r18, r24
    10f4:	21 f0       	breq	.+8      	; 0x10fe <control_change_password+0x56>
			{
				chg_miss_match++;
    10f6:	8d 8d       	ldd	r24, Y+29	; 0x1d
    10f8:	8f 5f       	subi	r24, 0xFF	; 255
    10fa:	8d 8f       	std	Y+29, r24	; 0x1d
    10fc:	06 c0       	rjmp	.+12     	; 0x110a <control_change_password+0x62>

	Get_pass_inside_EEEPROM(pass_in_EEPROM);
	receive_user_entered_pass(pass_chg_control);

	/********** MC2 Response *************/
		for(chg_counter=0;chg_counter<(password_length);chg_counter++)
    10fe:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1100:	8f 5f       	subi	r24, 0xFF	; 255
    1102:	8e 8f       	std	Y+30, r24	; 0x1e
    1104:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1106:	85 30       	cpi	r24, 0x05	; 5
    1108:	20 f3       	brcs	.-56     	; 0x10d2 <control_change_password+0x2a>
				chg_miss_match++;
				break;//no need to compare further
			}
		}

	UART_sendByte(USER_ACCESS);
    110a:	88 e1       	ldi	r24, 0x18	; 24
    110c:	0e 94 b1 11 	call	0x2362	; 0x2362 <UART_sendByte>
	if(chg_miss_match==0)//PASS match bet it and the saved pass in EEPROM
    1110:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1112:	88 23       	and	r24, r24
    1114:	39 f4       	brne	.+14     	; 0x1124 <control_change_password+0x7c>
	{
		UART_sendByte(PASSWORDS_IS_CORRECT);/**FIFTH time **/// Update saved password in EEPROM (missing logic added);
    1116:	89 e1       	ldi	r24, 0x19	; 25
    1118:	0e 94 b1 11 	call	0x2362	; 0x2362 <UART_sendByte>
		 check_created_password(new_sys_pass);
    111c:	ce 01       	movw	r24, r28
    111e:	84 96       	adiw	r24, 0x24	; 36
    1120:	0e 94 cc 05 	call	0xb98	; 0xb98 <check_created_password>
	}
	if (chg_miss_match!=0)
    1124:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1126:	88 23       	and	r24, r24
    1128:	09 f4       	brne	.+2      	; 0x112c <control_change_password+0x84>
    112a:	fe c0       	rjmp	.+508    	; 0x1328 <control_change_password+0x280>
	{
		counter_for_buzzer++;
    112c:	80 91 80 00 	lds	r24, 0x0080
    1130:	8f 5f       	subi	r24, 0xFF	; 255
    1132:	80 93 80 00 	sts	0x0080, r24
		UART_sendByte(PASSWORDS_DONT_MATCH);
    1136:	84 e1       	ldi	r24, 0x14	; 20
    1138:	0e 94 b1 11 	call	0x2362	; 0x2362 <UART_sendByte>
		if(counter_for_buzzer==3)
    113c:	80 91 80 00 	lds	r24, 0x0080
    1140:	83 30       	cpi	r24, 0x03	; 3
    1142:	09 f0       	breq	.+2      	; 0x1146 <control_change_password+0x9e>
    1144:	ef c0       	rjmp	.+478    	; 0x1324 <control_change_password+0x27c>
		  {
			  	  /********ACTIVATE ALARM*********/
		   Buzzer_on();//BUZZZER ON
    1146:	0e 94 b4 05 	call	0xb68	; 0xb68 <Buzzer_on>
    114a:	80 e0       	ldi	r24, 0x00	; 0
    114c:	90 e6       	ldi	r25, 0x60	; 96
    114e:	aa ee       	ldi	r26, 0xEA	; 234
    1150:	b6 e4       	ldi	r27, 0x46	; 70
    1152:	89 8f       	std	Y+25, r24	; 0x19
    1154:	9a 8f       	std	Y+26, r25	; 0x1a
    1156:	ab 8f       	std	Y+27, r26	; 0x1b
    1158:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    115a:	69 8d       	ldd	r22, Y+25	; 0x19
    115c:	7a 8d       	ldd	r23, Y+26	; 0x1a
    115e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1160:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1162:	20 e0       	ldi	r18, 0x00	; 0
    1164:	30 e0       	ldi	r19, 0x00	; 0
    1166:	4a ef       	ldi	r20, 0xFA	; 250
    1168:	54 e4       	ldi	r21, 0x44	; 68
    116a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    116e:	dc 01       	movw	r26, r24
    1170:	cb 01       	movw	r24, r22
    1172:	8d 8b       	std	Y+21, r24	; 0x15
    1174:	9e 8b       	std	Y+22, r25	; 0x16
    1176:	af 8b       	std	Y+23, r26	; 0x17
    1178:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    117a:	6d 89       	ldd	r22, Y+21	; 0x15
    117c:	7e 89       	ldd	r23, Y+22	; 0x16
    117e:	8f 89       	ldd	r24, Y+23	; 0x17
    1180:	98 8d       	ldd	r25, Y+24	; 0x18
    1182:	20 e0       	ldi	r18, 0x00	; 0
    1184:	30 e0       	ldi	r19, 0x00	; 0
    1186:	40 e8       	ldi	r20, 0x80	; 128
    1188:	5f e3       	ldi	r21, 0x3F	; 63
    118a:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    118e:	88 23       	and	r24, r24
    1190:	2c f4       	brge	.+10     	; 0x119c <control_change_password+0xf4>
		__ticks = 1;
    1192:	81 e0       	ldi	r24, 0x01	; 1
    1194:	90 e0       	ldi	r25, 0x00	; 0
    1196:	9c 8b       	std	Y+20, r25	; 0x14
    1198:	8b 8b       	std	Y+19, r24	; 0x13
    119a:	3f c0       	rjmp	.+126    	; 0x121a <control_change_password+0x172>
	else if (__tmp > 65535)
    119c:	6d 89       	ldd	r22, Y+21	; 0x15
    119e:	7e 89       	ldd	r23, Y+22	; 0x16
    11a0:	8f 89       	ldd	r24, Y+23	; 0x17
    11a2:	98 8d       	ldd	r25, Y+24	; 0x18
    11a4:	20 e0       	ldi	r18, 0x00	; 0
    11a6:	3f ef       	ldi	r19, 0xFF	; 255
    11a8:	4f e7       	ldi	r20, 0x7F	; 127
    11aa:	57 e4       	ldi	r21, 0x47	; 71
    11ac:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    11b0:	18 16       	cp	r1, r24
    11b2:	4c f5       	brge	.+82     	; 0x1206 <control_change_password+0x15e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    11b4:	69 8d       	ldd	r22, Y+25	; 0x19
    11b6:	7a 8d       	ldd	r23, Y+26	; 0x1a
    11b8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    11ba:	9c 8d       	ldd	r25, Y+28	; 0x1c
    11bc:	20 e0       	ldi	r18, 0x00	; 0
    11be:	30 e0       	ldi	r19, 0x00	; 0
    11c0:	40 e2       	ldi	r20, 0x20	; 32
    11c2:	51 e4       	ldi	r21, 0x41	; 65
    11c4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    11c8:	dc 01       	movw	r26, r24
    11ca:	cb 01       	movw	r24, r22
    11cc:	bc 01       	movw	r22, r24
    11ce:	cd 01       	movw	r24, r26
    11d0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    11d4:	dc 01       	movw	r26, r24
    11d6:	cb 01       	movw	r24, r22
    11d8:	9c 8b       	std	Y+20, r25	; 0x14
    11da:	8b 8b       	std	Y+19, r24	; 0x13
    11dc:	0f c0       	rjmp	.+30     	; 0x11fc <control_change_password+0x154>
    11de:	88 ec       	ldi	r24, 0xC8	; 200
    11e0:	90 e0       	ldi	r25, 0x00	; 0
    11e2:	9a 8b       	std	Y+18, r25	; 0x12
    11e4:	89 8b       	std	Y+17, r24	; 0x11
    11e6:	89 89       	ldd	r24, Y+17	; 0x11
    11e8:	9a 89       	ldd	r25, Y+18	; 0x12
    11ea:	01 97       	sbiw	r24, 0x01	; 1
    11ec:	f1 f7       	brne	.-4      	; 0x11ea <control_change_password+0x142>
    11ee:	9a 8b       	std	Y+18, r25	; 0x12
    11f0:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    11f2:	8b 89       	ldd	r24, Y+19	; 0x13
    11f4:	9c 89       	ldd	r25, Y+20	; 0x14
    11f6:	01 97       	sbiw	r24, 0x01	; 1
    11f8:	9c 8b       	std	Y+20, r25	; 0x14
    11fa:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    11fc:	8b 89       	ldd	r24, Y+19	; 0x13
    11fe:	9c 89       	ldd	r25, Y+20	; 0x14
    1200:	00 97       	sbiw	r24, 0x00	; 0
    1202:	69 f7       	brne	.-38     	; 0x11de <control_change_password+0x136>
    1204:	14 c0       	rjmp	.+40     	; 0x122e <control_change_password+0x186>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1206:	6d 89       	ldd	r22, Y+21	; 0x15
    1208:	7e 89       	ldd	r23, Y+22	; 0x16
    120a:	8f 89       	ldd	r24, Y+23	; 0x17
    120c:	98 8d       	ldd	r25, Y+24	; 0x18
    120e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1212:	dc 01       	movw	r26, r24
    1214:	cb 01       	movw	r24, r22
    1216:	9c 8b       	std	Y+20, r25	; 0x14
    1218:	8b 8b       	std	Y+19, r24	; 0x13
    121a:	8b 89       	ldd	r24, Y+19	; 0x13
    121c:	9c 89       	ldd	r25, Y+20	; 0x14
    121e:	98 8b       	std	Y+16, r25	; 0x10
    1220:	8f 87       	std	Y+15, r24	; 0x0f
    1222:	8f 85       	ldd	r24, Y+15	; 0x0f
    1224:	98 89       	ldd	r25, Y+16	; 0x10
    1226:	01 97       	sbiw	r24, 0x01	; 1
    1228:	f1 f7       	brne	.-4      	; 0x1226 <control_change_password+0x17e>
    122a:	98 8b       	std	Y+16, r25	; 0x10
    122c:	8f 87       	std	Y+15, r24	; 0x0f
    122e:	80 e0       	ldi	r24, 0x00	; 0
    1230:	90 e6       	ldi	r25, 0x60	; 96
    1232:	aa ee       	ldi	r26, 0xEA	; 234
    1234:	b6 e4       	ldi	r27, 0x46	; 70
    1236:	8b 87       	std	Y+11, r24	; 0x0b
    1238:	9c 87       	std	Y+12, r25	; 0x0c
    123a:	ad 87       	std	Y+13, r26	; 0x0d
    123c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    123e:	6b 85       	ldd	r22, Y+11	; 0x0b
    1240:	7c 85       	ldd	r23, Y+12	; 0x0c
    1242:	8d 85       	ldd	r24, Y+13	; 0x0d
    1244:	9e 85       	ldd	r25, Y+14	; 0x0e
    1246:	20 e0       	ldi	r18, 0x00	; 0
    1248:	30 e0       	ldi	r19, 0x00	; 0
    124a:	4a ef       	ldi	r20, 0xFA	; 250
    124c:	54 e4       	ldi	r21, 0x44	; 68
    124e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1252:	dc 01       	movw	r26, r24
    1254:	cb 01       	movw	r24, r22
    1256:	8f 83       	std	Y+7, r24	; 0x07
    1258:	98 87       	std	Y+8, r25	; 0x08
    125a:	a9 87       	std	Y+9, r26	; 0x09
    125c:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    125e:	6f 81       	ldd	r22, Y+7	; 0x07
    1260:	78 85       	ldd	r23, Y+8	; 0x08
    1262:	89 85       	ldd	r24, Y+9	; 0x09
    1264:	9a 85       	ldd	r25, Y+10	; 0x0a
    1266:	20 e0       	ldi	r18, 0x00	; 0
    1268:	30 e0       	ldi	r19, 0x00	; 0
    126a:	40 e8       	ldi	r20, 0x80	; 128
    126c:	5f e3       	ldi	r21, 0x3F	; 63
    126e:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1272:	88 23       	and	r24, r24
    1274:	2c f4       	brge	.+10     	; 0x1280 <control_change_password+0x1d8>
		__ticks = 1;
    1276:	81 e0       	ldi	r24, 0x01	; 1
    1278:	90 e0       	ldi	r25, 0x00	; 0
    127a:	9e 83       	std	Y+6, r25	; 0x06
    127c:	8d 83       	std	Y+5, r24	; 0x05
    127e:	3f c0       	rjmp	.+126    	; 0x12fe <control_change_password+0x256>
	else if (__tmp > 65535)
    1280:	6f 81       	ldd	r22, Y+7	; 0x07
    1282:	78 85       	ldd	r23, Y+8	; 0x08
    1284:	89 85       	ldd	r24, Y+9	; 0x09
    1286:	9a 85       	ldd	r25, Y+10	; 0x0a
    1288:	20 e0       	ldi	r18, 0x00	; 0
    128a:	3f ef       	ldi	r19, 0xFF	; 255
    128c:	4f e7       	ldi	r20, 0x7F	; 127
    128e:	57 e4       	ldi	r21, 0x47	; 71
    1290:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1294:	18 16       	cp	r1, r24
    1296:	4c f5       	brge	.+82     	; 0x12ea <control_change_password+0x242>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1298:	6b 85       	ldd	r22, Y+11	; 0x0b
    129a:	7c 85       	ldd	r23, Y+12	; 0x0c
    129c:	8d 85       	ldd	r24, Y+13	; 0x0d
    129e:	9e 85       	ldd	r25, Y+14	; 0x0e
    12a0:	20 e0       	ldi	r18, 0x00	; 0
    12a2:	30 e0       	ldi	r19, 0x00	; 0
    12a4:	40 e2       	ldi	r20, 0x20	; 32
    12a6:	51 e4       	ldi	r21, 0x41	; 65
    12a8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    12ac:	dc 01       	movw	r26, r24
    12ae:	cb 01       	movw	r24, r22
    12b0:	bc 01       	movw	r22, r24
    12b2:	cd 01       	movw	r24, r26
    12b4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    12b8:	dc 01       	movw	r26, r24
    12ba:	cb 01       	movw	r24, r22
    12bc:	9e 83       	std	Y+6, r25	; 0x06
    12be:	8d 83       	std	Y+5, r24	; 0x05
    12c0:	0f c0       	rjmp	.+30     	; 0x12e0 <control_change_password+0x238>
    12c2:	88 ec       	ldi	r24, 0xC8	; 200
    12c4:	90 e0       	ldi	r25, 0x00	; 0
    12c6:	9c 83       	std	Y+4, r25	; 0x04
    12c8:	8b 83       	std	Y+3, r24	; 0x03
    12ca:	8b 81       	ldd	r24, Y+3	; 0x03
    12cc:	9c 81       	ldd	r25, Y+4	; 0x04
    12ce:	01 97       	sbiw	r24, 0x01	; 1
    12d0:	f1 f7       	brne	.-4      	; 0x12ce <control_change_password+0x226>
    12d2:	9c 83       	std	Y+4, r25	; 0x04
    12d4:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    12d6:	8d 81       	ldd	r24, Y+5	; 0x05
    12d8:	9e 81       	ldd	r25, Y+6	; 0x06
    12da:	01 97       	sbiw	r24, 0x01	; 1
    12dc:	9e 83       	std	Y+6, r25	; 0x06
    12de:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    12e0:	8d 81       	ldd	r24, Y+5	; 0x05
    12e2:	9e 81       	ldd	r25, Y+6	; 0x06
    12e4:	00 97       	sbiw	r24, 0x00	; 0
    12e6:	69 f7       	brne	.-38     	; 0x12c2 <control_change_password+0x21a>
    12e8:	14 c0       	rjmp	.+40     	; 0x1312 <control_change_password+0x26a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    12ea:	6f 81       	ldd	r22, Y+7	; 0x07
    12ec:	78 85       	ldd	r23, Y+8	; 0x08
    12ee:	89 85       	ldd	r24, Y+9	; 0x09
    12f0:	9a 85       	ldd	r25, Y+10	; 0x0a
    12f2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    12f6:	dc 01       	movw	r26, r24
    12f8:	cb 01       	movw	r24, r22
    12fa:	9e 83       	std	Y+6, r25	; 0x06
    12fc:	8d 83       	std	Y+5, r24	; 0x05
    12fe:	8d 81       	ldd	r24, Y+5	; 0x05
    1300:	9e 81       	ldd	r25, Y+6	; 0x06
    1302:	9a 83       	std	Y+2, r25	; 0x02
    1304:	89 83       	std	Y+1, r24	; 0x01
    1306:	89 81       	ldd	r24, Y+1	; 0x01
    1308:	9a 81       	ldd	r25, Y+2	; 0x02
    130a:	01 97       	sbiw	r24, 0x01	; 1
    130c:	f1 f7       	brne	.-4      	; 0x130a <control_change_password+0x262>
    130e:	9a 83       	std	Y+2, r25	; 0x02
    1310:	89 83       	std	Y+1, r24	; 0x01
		   _delay_ms(30000);//keep Buzzer ON for  1 minute
		   _delay_ms(30000);
		   UART_sendByte(UNBLOCK_THE_SYSTEM);
    1312:	81 e2       	ldi	r24, 0x21	; 33
    1314:	0e 94 b1 11 	call	0x2362	; 0x2362 <UART_sendByte>
		   counter_for_buzzer=0;//so i cna count again
    1318:	10 92 80 00 	sts	0x0080, r1
		   Buzzer_off();
    131c:	0e 94 c0 05 	call	0xb80	; 0xb80 <Buzzer_off>
		   MAIN_options_control();/** back to step2**/
    1320:	0e 94 b6 06 	call	0xd6c	; 0xd6c <MAIN_options_control>
		  }
		control_change_password();
    1324:	0e 94 54 08 	call	0x10a8	; 0x10a8 <control_change_password>
	}

}
    1328:	a8 96       	adiw	r28, 0x28	; 40
    132a:	0f b6       	in	r0, 0x3f	; 63
    132c:	f8 94       	cli
    132e:	de bf       	out	0x3e, r29	; 62
    1330:	0f be       	out	0x3f, r0	; 63
    1332:	cd bf       	out	0x3d, r28	; 61
    1334:	cf 91       	pop	r28
    1336:	df 91       	pop	r29
    1338:	08 95       	ret

0000133a <Save_to_EEPROM>:
/********************************************************************************/
void Save_to_EEPROM(uint8 *system_password){
    133a:	df 93       	push	r29
    133c:	cf 93       	push	r28
    133e:	00 d0       	rcall	.+0      	; 0x1340 <Save_to_EEPROM+0x6>
    1340:	0f 92       	push	r0
    1342:	cd b7       	in	r28, 0x3d	; 61
    1344:	de b7       	in	r29, 0x3e	; 62
    1346:	9b 83       	std	Y+3, r25	; 0x03
    1348:	8a 83       	std	Y+2, r24	; 0x02
	//get_pass_inside_EEEPROM(saved_password); // Read the existing password from EEPROM
	/*Save_to_EEPROM(entered_password); // Update the saved password in EEPROM with the entered password
		        _delay_ms(30);
		        Get_pass_inside_EEEPROM(saved_password); // Update the saved_password array with the new password from EEPROM
		        _delay_ms(30);*/
	for(counter=0;counter<(password_length);counter++)
    134a:	19 82       	std	Y+1, r1	; 0x01
    134c:	16 c0       	rjmp	.+44     	; 0x137a <Save_to_EEPROM+0x40>
			{
				EEPROM_writeByte(((0x0311)+counter),system_password[counter]);
    134e:	89 81       	ldd	r24, Y+1	; 0x01
    1350:	88 2f       	mov	r24, r24
    1352:	90 e0       	ldi	r25, 0x00	; 0
    1354:	8f 5e       	subi	r24, 0xEF	; 239
    1356:	9c 4f       	sbci	r25, 0xFC	; 252
    1358:	ac 01       	movw	r20, r24
    135a:	89 81       	ldd	r24, Y+1	; 0x01
    135c:	28 2f       	mov	r18, r24
    135e:	30 e0       	ldi	r19, 0x00	; 0
    1360:	8a 81       	ldd	r24, Y+2	; 0x02
    1362:	9b 81       	ldd	r25, Y+3	; 0x03
    1364:	fc 01       	movw	r30, r24
    1366:	e2 0f       	add	r30, r18
    1368:	f3 1f       	adc	r31, r19
    136a:	20 81       	ld	r18, Z
    136c:	ca 01       	movw	r24, r20
    136e:	62 2f       	mov	r22, r18
    1370:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <EEPROM_writeByte>
	//get_pass_inside_EEEPROM(saved_password); // Read the existing password from EEPROM
	/*Save_to_EEPROM(entered_password); // Update the saved password in EEPROM with the entered password
		        _delay_ms(30);
		        Get_pass_inside_EEEPROM(saved_password); // Update the saved_password array with the new password from EEPROM
		        _delay_ms(30);*/
	for(counter=0;counter<(password_length);counter++)
    1374:	89 81       	ldd	r24, Y+1	; 0x01
    1376:	8f 5f       	subi	r24, 0xFF	; 255
    1378:	89 83       	std	Y+1, r24	; 0x01
    137a:	89 81       	ldd	r24, Y+1	; 0x01
    137c:	85 30       	cpi	r24, 0x05	; 5
    137e:	38 f3       	brcs	.-50     	; 0x134e <Save_to_EEPROM+0x14>
			{
				EEPROM_writeByte(((0x0311)+counter),system_password[counter]);
			}
	//update pass_in_EEPROM[password_length]; variable each time i save anew pass
		for(counter=0;counter<(password_length);counter++){
    1380:	19 82       	std	Y+1, r1	; 0x01
    1382:	13 c0       	rjmp	.+38     	; 0x13aa <Save_to_EEPROM+0x70>
			pass_in_EEPROM[counter]=system_password[counter];
    1384:	89 81       	ldd	r24, Y+1	; 0x01
    1386:	48 2f       	mov	r20, r24
    1388:	50 e0       	ldi	r21, 0x00	; 0
    138a:	89 81       	ldd	r24, Y+1	; 0x01
    138c:	28 2f       	mov	r18, r24
    138e:	30 e0       	ldi	r19, 0x00	; 0
    1390:	8a 81       	ldd	r24, Y+2	; 0x02
    1392:	9b 81       	ldd	r25, Y+3	; 0x03
    1394:	fc 01       	movw	r30, r24
    1396:	e2 0f       	add	r30, r18
    1398:	f3 1f       	adc	r31, r19
    139a:	80 81       	ld	r24, Z
    139c:	fa 01       	movw	r30, r20
    139e:	ef 58       	subi	r30, 0x8F	; 143
    13a0:	ff 4f       	sbci	r31, 0xFF	; 255
    13a2:	80 83       	st	Z, r24
	for(counter=0;counter<(password_length);counter++)
			{
				EEPROM_writeByte(((0x0311)+counter),system_password[counter]);
			}
	//update pass_in_EEPROM[password_length]; variable each time i save anew pass
		for(counter=0;counter<(password_length);counter++){
    13a4:	89 81       	ldd	r24, Y+1	; 0x01
    13a6:	8f 5f       	subi	r24, 0xFF	; 255
    13a8:	89 83       	std	Y+1, r24	; 0x01
    13aa:	89 81       	ldd	r24, Y+1	; 0x01
    13ac:	85 30       	cpi	r24, 0x05	; 5
    13ae:	50 f3       	brcs	.-44     	; 0x1384 <Save_to_EEPROM+0x4a>
			pass_in_EEPROM[counter]=system_password[counter];
		}
}
    13b0:	0f 90       	pop	r0
    13b2:	0f 90       	pop	r0
    13b4:	0f 90       	pop	r0
    13b6:	cf 91       	pop	r28
    13b8:	df 91       	pop	r29
    13ba:	08 95       	ret

000013bc <Get_pass_inside_EEEPROM>:
/********************************************************************************/
void Get_pass_inside_EEEPROM(uint8 *saved_password){
    13bc:	df 93       	push	r29
    13be:	cf 93       	push	r28
    13c0:	00 d0       	rcall	.+0      	; 0x13c2 <Get_pass_inside_EEEPROM+0x6>
    13c2:	0f 92       	push	r0
    13c4:	cd b7       	in	r28, 0x3d	; 61
    13c6:	de b7       	in	r29, 0x3e	; 62
    13c8:	9b 83       	std	Y+3, r25	; 0x03
    13ca:	8a 83       	std	Y+2, r24	; 0x02
	uint8 counter;
	for(counter=0;counter<(password_length);counter++)
    13cc:	19 82       	std	Y+1, r1	; 0x01
    13ce:	14 c0       	rjmp	.+40     	; 0x13f8 <Get_pass_inside_EEEPROM+0x3c>
				{
					EEPROM_readByte(((0x0311)+counter),&(saved_password[counter]));
    13d0:	89 81       	ldd	r24, Y+1	; 0x01
    13d2:	88 2f       	mov	r24, r24
    13d4:	90 e0       	ldi	r25, 0x00	; 0
    13d6:	8f 5e       	subi	r24, 0xEF	; 239
    13d8:	9c 4f       	sbci	r25, 0xFC	; 252
    13da:	ac 01       	movw	r20, r24
    13dc:	89 81       	ldd	r24, Y+1	; 0x01
    13de:	28 2f       	mov	r18, r24
    13e0:	30 e0       	ldi	r19, 0x00	; 0
    13e2:	8a 81       	ldd	r24, Y+2	; 0x02
    13e4:	9b 81       	ldd	r25, Y+3	; 0x03
    13e6:	28 0f       	add	r18, r24
    13e8:	39 1f       	adc	r19, r25
    13ea:	ca 01       	movw	r24, r20
    13ec:	b9 01       	movw	r22, r18
    13ee:	0e 94 33 0c 	call	0x1866	; 0x1866 <EEPROM_readByte>
		}
}
/********************************************************************************/
void Get_pass_inside_EEEPROM(uint8 *saved_password){
	uint8 counter;
	for(counter=0;counter<(password_length);counter++)
    13f2:	89 81       	ldd	r24, Y+1	; 0x01
    13f4:	8f 5f       	subi	r24, 0xFF	; 255
    13f6:	89 83       	std	Y+1, r24	; 0x01
    13f8:	89 81       	ldd	r24, Y+1	; 0x01
    13fa:	85 30       	cpi	r24, 0x05	; 5
    13fc:	48 f3       	brcs	.-46     	; 0x13d0 <Get_pass_inside_EEEPROM+0x14>
				{
					EEPROM_readByte(((0x0311)+counter),&(saved_password[counter]));
				}


}
    13fe:	0f 90       	pop	r0
    1400:	0f 90       	pop	r0
    1402:	0f 90       	pop	r0
    1404:	cf 91       	pop	r28
    1406:	df 91       	pop	r29
    1408:	08 95       	ret

0000140a <main>:
/********************************************************************************/
int main(){
    140a:	df 93       	push	r29
    140c:	cf 93       	push	r28
    140e:	00 d0       	rcall	.+0      	; 0x1410 <main+0x6>
    1410:	00 d0       	rcall	.+0      	; 0x1412 <main+0x8>
    1412:	0f 92       	push	r0
    1414:	cd b7       	in	r28, 0x3d	; 61
    1416:	de b7       	in	r29, 0x3e	; 62
		/************Initialization*******************/
		/* Initialize the EEPROM Driver */
		EEPROM_init();
    1418:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <EEPROM_init>

		Buzzer_init();
    141c:	0e 94 a3 05 	call	0xb46	; 0xb46 <Buzzer_init>
	     • Date Length: 8-Bits Data
		 • Parity Type: Even Parity
		 • Stop Bits: 1-Stop Bit
		 • Baud-rate = 9600 bits/sec */
		// Setting configuration values
		 uartConfig.bit_data = eight_bit;
    1420:	83 e0       	ldi	r24, 0x03	; 3
    1422:	80 93 79 00 	sts	0x0079, r24
		 uartConfig.parity = even_parity;
    1426:	82 e0       	ldi	r24, 0x02	; 2
    1428:	80 93 7a 00 	sts	0x007A, r24
		 uartConfig.stop_bit = one_Bit;
    142c:	10 92 7b 00 	sts	0x007B, r1
		 uartConfig.baud_rate = baud_9600;
    1430:	80 e8       	ldi	r24, 0x80	; 128
    1432:	95 e2       	ldi	r25, 0x25	; 37
    1434:	a0 e0       	ldi	r26, 0x00	; 0
    1436:	b0 e0       	ldi	r27, 0x00	; 0
    1438:	80 93 7c 00 	sts	0x007C, r24
    143c:	90 93 7d 00 	sts	0x007D, r25
    1440:	a0 93 7e 00 	sts	0x007E, r26
    1444:	b0 93 7f 00 	sts	0x007F, r27
		 // Initializing UART with the configuration
		UART_init(&uartConfig);
    1448:	89 e7       	ldi	r24, 0x79	; 121
    144a:	90 e0       	ldi	r25, 0x00	; 0
    144c:	0e 94 17 11 	call	0x222e	; 0x222e <UART_init>

		DcMotor_Init();
    1450:	0e 94 01 10 	call	0x2002	; 0x2002 <DcMotor_Init>

		DcMotor_Rotate(MOTOR_OFF,0);//initial state
    1454:	80 e0       	ldi	r24, 0x00	; 0
    1456:	60 e0       	ldi	r22, 0x00	; 0
    1458:	0e 94 1b 10 	call	0x2036	; 0x2036 <DcMotor_Rotate>
		uint8 entered_password[password_length];//to initialize system
		/******************************************/
  while(1)
  {

	check_created_password(entered_password);/**step1**/
    145c:	ce 01       	movw	r24, r28
    145e:	01 96       	adiw	r24, 0x01	; 1
    1460:	0e 94 cc 05 	call	0xb98	; 0xb98 <check_created_password>
    1464:	fb cf       	rjmp	.-10     	; 0x145c <main+0x52>

00001466 <TWI_init>:
#include "I2C_mine.h"
#include "common_macros.h"
#include <avr/io.h>

void TWI_init(const TWI_ConfigType * Config_Ptr)
{
    1466:	df 93       	push	r29
    1468:	cf 93       	push	r28
    146a:	00 d0       	rcall	.+0      	; 0x146c <TWI_init+0x6>
    146c:	00 d0       	rcall	.+0      	; 0x146e <TWI_init+0x8>
    146e:	0f 92       	push	r0
    1470:	cd b7       	in	r28, 0x3d	; 61
    1472:	de b7       	in	r29, 0x3e	; 62
    1474:	9b 83       	std	Y+3, r25	; 0x03
    1476:	8a 83       	std	Y+2, r24	; 0x02
	uint8 TWBR_value;

	switch(Config_Ptr->bit_rate)
    1478:	ea 81       	ldd	r30, Y+2	; 0x02
    147a:	fb 81       	ldd	r31, Y+3	; 0x03
    147c:	81 81       	ldd	r24, Z+1	; 0x01
    147e:	28 2f       	mov	r18, r24
    1480:	30 e0       	ldi	r19, 0x00	; 0
    1482:	3d 83       	std	Y+5, r19	; 0x05
    1484:	2c 83       	std	Y+4, r18	; 0x04
    1486:	8c 81       	ldd	r24, Y+4	; 0x04
    1488:	9d 81       	ldd	r25, Y+5	; 0x05
    148a:	81 30       	cpi	r24, 0x01	; 1
    148c:	91 05       	cpc	r25, r1
    148e:	c1 f0       	breq	.+48     	; 0x14c0 <TWI_init+0x5a>
    1490:	2c 81       	ldd	r18, Y+4	; 0x04
    1492:	3d 81       	ldd	r19, Y+5	; 0x05
    1494:	22 30       	cpi	r18, 0x02	; 2
    1496:	31 05       	cpc	r19, r1
    1498:	2c f4       	brge	.+10     	; 0x14a4 <TWI_init+0x3e>
    149a:	8c 81       	ldd	r24, Y+4	; 0x04
    149c:	9d 81       	ldd	r25, Y+5	; 0x05
    149e:	00 97       	sbiw	r24, 0x00	; 0
    14a0:	61 f0       	breq	.+24     	; 0x14ba <TWI_init+0x54>
    14a2:	16 c0       	rjmp	.+44     	; 0x14d0 <TWI_init+0x6a>
    14a4:	2c 81       	ldd	r18, Y+4	; 0x04
    14a6:	3d 81       	ldd	r19, Y+5	; 0x05
    14a8:	22 30       	cpi	r18, 0x02	; 2
    14aa:	31 05       	cpc	r19, r1
    14ac:	61 f0       	breq	.+24     	; 0x14c6 <TWI_init+0x60>
    14ae:	8c 81       	ldd	r24, Y+4	; 0x04
    14b0:	9d 81       	ldd	r25, Y+5	; 0x05
    14b2:	83 30       	cpi	r24, 0x03	; 3
    14b4:	91 05       	cpc	r25, r1
    14b6:	51 f0       	breq	.+20     	; 0x14cc <TWI_init+0x66>
    14b8:	0b c0       	rjmp	.+22     	; 0x14d0 <TWI_init+0x6a>
	{
	case TWI_BaudRate_100_KB_persec:
		/*SCL freq=10kbs*/
		TWBR_value=(((F_CPU/100000)-16)/(2*pow(4,TWPS)));
    14ba:	80 e2       	ldi	r24, 0x20	; 32
    14bc:	89 83       	std	Y+1, r24	; 0x01
    14be:	08 c0       	rjmp	.+16     	; 0x14d0 <TWI_init+0x6a>
		break;
	case TWI_BaudRate_400_KB_persec:
		/*SCL freq=40kbs*/
		TWBR_value=(((F_CPU/400000)-16)/(2*pow(4,TWPS)));
    14c0:	82 e0       	ldi	r24, 0x02	; 2
    14c2:	89 83       	std	Y+1, r24	; 0x01
    14c4:	05 c0       	rjmp	.+10     	; 0x14d0 <TWI_init+0x6a>
		break;
	case TWI_BaudRate_1_MB_persec:
		/*SCL freq=1mbs*/
		TWBR_value=(((F_CPU/1000000)-16)/(2*pow(4,TWPS)));
    14c6:	8f ef       	ldi	r24, 0xFF	; 255
    14c8:	89 83       	std	Y+1, r24	; 0x01
    14ca:	02 c0       	rjmp	.+4      	; 0x14d0 <TWI_init+0x6a>
		break;
	case TWI_BaudRate_3_point_four_MB_persec:
		/*SCL freq=3.4mbs*/
		TWBR_value=(((F_CPU/3400000)-16)/(2*pow(4,TWPS)));
    14cc:	8f ef       	ldi	r24, 0xFF	; 255
    14ce:	89 83       	std	Y+1, r24	; 0x01
		break;
	}
	/*set pre_scaler*/
	TWBR=TWBR_value;
    14d0:	e0 e2       	ldi	r30, 0x20	; 32
    14d2:	f0 e0       	ldi	r31, 0x00	; 0
    14d4:	89 81       	ldd	r24, Y+1	; 0x01
    14d6:	80 83       	st	Z, r24
	TWSR = TWPS;
    14d8:	e1 e2       	ldi	r30, 0x21	; 33
    14da:	f0 e0       	ldi	r31, 0x00	; 0
    14dc:	10 82       	st	Z, r1
	// Set device address in TWAR register(clear TWGCE for MASTER)
	TWAR = ((Config_Ptr->address << 1)& ~TWGCE); // Device address left-shifted by 1
    14de:	a2 e2       	ldi	r26, 0x22	; 34
    14e0:	b0 e0       	ldi	r27, 0x00	; 0
    14e2:	ea 81       	ldd	r30, Y+2	; 0x02
    14e4:	fb 81       	ldd	r31, Y+3	; 0x03
    14e6:	80 81       	ld	r24, Z
    14e8:	88 0f       	add	r24, r24
    14ea:	8c 93       	st	X, r24


    TWCR = (1<<TWEN); /* enable TWI */
    14ec:	e6 e5       	ldi	r30, 0x56	; 86
    14ee:	f0 e0       	ldi	r31, 0x00	; 0
    14f0:	84 e0       	ldi	r24, 0x04	; 4
    14f2:	80 83       	st	Z, r24
}
    14f4:	0f 90       	pop	r0
    14f6:	0f 90       	pop	r0
    14f8:	0f 90       	pop	r0
    14fa:	0f 90       	pop	r0
    14fc:	0f 90       	pop	r0
    14fe:	cf 91       	pop	r28
    1500:	df 91       	pop	r29
    1502:	08 95       	ret

00001504 <TWI_start>:


void TWI_start(void)
{
    1504:	df 93       	push	r29
    1506:	cf 93       	push	r28
    1508:	cd b7       	in	r28, 0x3d	; 61
    150a:	de b7       	in	r29, 0x3e	; 62
	 *
	 * Enable TWI Module TWEN=1
	 *   It should be set along with the other bits
	 *   to ensure that the TWI module is enabled at the same time as initiating the start condition.
	 */
    TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN);
    150c:	e6 e5       	ldi	r30, 0x56	; 86
    150e:	f0 e0       	ldi	r31, 0x00	; 0
    1510:	84 ea       	ldi	r24, 0xA4	; 164
    1512:	80 83       	st	Z, r24
     * protocol and ensures proper operation of the TWI hardware.
     */


    /* Wait for TWINT flag set in TWCR Register (start bit is send successfully) */
    while(BIT_IS_CLEAR(TWCR,TWINT));
    1514:	e6 e5       	ldi	r30, 0x56	; 86
    1516:	f0 e0       	ldi	r31, 0x00	; 0
    1518:	80 81       	ld	r24, Z
    151a:	88 23       	and	r24, r24
    151c:	dc f7       	brge	.-10     	; 0x1514 <TWI_start+0x10>
}
    151e:	cf 91       	pop	r28
    1520:	df 91       	pop	r29
    1522:	08 95       	ret

00001524 <TWI_stop>:

void TWI_stop(void)
{
    1524:	df 93       	push	r29
    1526:	cf 93       	push	r28
    1528:	cd b7       	in	r28, 0x3d	; 61
    152a:	de b7       	in	r29, 0x3e	; 62
    /*
	 * Clear the TWINT flag before sending the stop bit TWINT=1
	 * send the stop bit by TWSTO=1
	 * Enable TWI Module TWEN=1
	 */
    TWCR = (1 << TWINT) | (1 << TWSTO) | (1 << TWEN);
    152c:	e6 e5       	ldi	r30, 0x56	; 86
    152e:	f0 e0       	ldi	r31, 0x00	; 0
    1530:	84 e9       	ldi	r24, 0x94	; 148
    1532:	80 83       	st	Z, r24
}
    1534:	cf 91       	pop	r28
    1536:	df 91       	pop	r29
    1538:	08 95       	ret

0000153a <TWI_writeByte>:

void TWI_writeByte(uint8 data)
{
    153a:	df 93       	push	r29
    153c:	cf 93       	push	r28
    153e:	0f 92       	push	r0
    1540:	cd b7       	in	r28, 0x3d	; 61
    1542:	de b7       	in	r29, 0x3e	; 62
    1544:	89 83       	std	Y+1, r24	; 0x01
	/* Put data On TWI data Register */
	    TWDR = data;
    1546:	e3 e2       	ldi	r30, 0x23	; 35
    1548:	f0 e0       	ldi	r31, 0x00	; 0
    154a:	89 81       	ldd	r24, Y+1	; 0x01
    154c:	80 83       	st	Z, r24
	/*
	 * Clear the TWINT flag before sending the data TWINT=1
	 * Enable TWI Module TWEN=1
	 */
	 TWCR = (1 << TWINT) | (1 << TWEN);
    154e:	e6 e5       	ldi	r30, 0x56	; 86
    1550:	f0 e0       	ldi	r31, 0x00	; 0
    1552:	84 e8       	ldi	r24, 0x84	; 132
    1554:	80 83       	st	Z, r24
 /* Wait for TWINT flag set in TWCR Register(data is send successfully) */
	 while(BIT_IS_CLEAR(TWCR,TWINT));
    1556:	e6 e5       	ldi	r30, 0x56	; 86
    1558:	f0 e0       	ldi	r31, 0x00	; 0
    155a:	80 81       	ld	r24, Z
    155c:	88 23       	and	r24, r24
    155e:	dc f7       	brge	.-10     	; 0x1556 <TWI_writeByte+0x1c>
}
    1560:	0f 90       	pop	r0
    1562:	cf 91       	pop	r28
    1564:	df 91       	pop	r29
    1566:	08 95       	ret

00001568 <TWI_readByteWithACK>:

uint8 TWI_readByteWithACK(void)
{
    1568:	df 93       	push	r29
    156a:	cf 93       	push	r28
    156c:	cd b7       	in	r28, 0x3d	; 61
    156e:	de b7       	in	r29, 0x3e	; 62
	/*
	 * Clear the TWINT flag before reading the data TWINT=1
	 * Enable sending ACK after reading or receiving data TWEA=1
	 * Enable TWI Module TWEN=1
	 */
    TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWEA);
    1570:	e6 e5       	ldi	r30, 0x56	; 86
    1572:	f0 e0       	ldi	r31, 0x00	; 0
    1574:	84 ec       	ldi	r24, 0xC4	; 196
    1576:	80 83       	st	Z, r24
    /* Wait for TWINT flag set in TWCR Register (data received successfully) */
    while(BIT_IS_CLEAR(TWCR,TWINT));
    1578:	e6 e5       	ldi	r30, 0x56	; 86
    157a:	f0 e0       	ldi	r31, 0x00	; 0
    157c:	80 81       	ld	r24, Z
    157e:	88 23       	and	r24, r24
    1580:	dc f7       	brge	.-10     	; 0x1578 <TWI_readByteWithACK+0x10>
    /* Read Data */
    return TWDR;
    1582:	e3 e2       	ldi	r30, 0x23	; 35
    1584:	f0 e0       	ldi	r31, 0x00	; 0
    1586:	80 81       	ld	r24, Z
}
    1588:	cf 91       	pop	r28
    158a:	df 91       	pop	r29
    158c:	08 95       	ret

0000158e <TWI_readByteWithNACK>:

uint8 TWI_readByteWithNACK(void)
{
    158e:	df 93       	push	r29
    1590:	cf 93       	push	r28
    1592:	cd b7       	in	r28, 0x3d	; 61
    1594:	de b7       	in	r29, 0x3e	; 62
	/*
	 * Clear the TWINT flag before reading the data TWINT=1
	 * Enable TWI Module TWEN=1
	 */
    TWCR = (1 << TWINT) | (1 << TWEN);
    1596:	e6 e5       	ldi	r30, 0x56	; 86
    1598:	f0 e0       	ldi	r31, 0x00	; 0
    159a:	84 e8       	ldi	r24, 0x84	; 132
    159c:	80 83       	st	Z, r24
    /* Wait for TWINT flag set in TWCR Register (data received successfully) */
    while(BIT_IS_CLEAR(TWCR,TWINT));
    159e:	e6 e5       	ldi	r30, 0x56	; 86
    15a0:	f0 e0       	ldi	r31, 0x00	; 0
    15a2:	80 81       	ld	r24, Z
    15a4:	88 23       	and	r24, r24
    15a6:	dc f7       	brge	.-10     	; 0x159e <TWI_readByteWithNACK+0x10>
    /* Read Data */
    return TWDR;
    15a8:	e3 e2       	ldi	r30, 0x23	; 35
    15aa:	f0 e0       	ldi	r31, 0x00	; 0
    15ac:	80 81       	ld	r24, Z
}
    15ae:	cf 91       	pop	r28
    15b0:	df 91       	pop	r29
    15b2:	08 95       	ret

000015b4 <TWI_getStatus>:

uint8 TWI_getStatus(void)
{
    15b4:	df 93       	push	r29
    15b6:	cf 93       	push	r28
    15b8:	0f 92       	push	r0
    15ba:	cd b7       	in	r28, 0x3d	; 61
    15bc:	de b7       	in	r29, 0x3e	; 62
    uint8 status;
    /* masking to eliminate first 3 bits and get the last 5 bits (status bits) */
    status = TWSR & 0xF8;
    15be:	e1 e2       	ldi	r30, 0x21	; 33
    15c0:	f0 e0       	ldi	r31, 0x00	; 0
    15c2:	80 81       	ld	r24, Z
    15c4:	88 7f       	andi	r24, 0xF8	; 248
    15c6:	89 83       	std	Y+1, r24	; 0x01
    return status;
    15c8:	89 81       	ldd	r24, Y+1	; 0x01
}
    15ca:	0f 90       	pop	r0
    15cc:	cf 91       	pop	r28
    15ce:	df 91       	pop	r29
    15d0:	08 95       	ret

000015d2 <__vector_9>:

/**definition of the pointer used to call back function**/
static volatile void(*g_ptr_callBack)(void) = NULL_PTR;
uint8 timer_ticks=0;
/**NORMAL mode ISR**/
ISR(TIMER1_OVF_vect){
    15d2:	1f 92       	push	r1
    15d4:	0f 92       	push	r0
    15d6:	0f b6       	in	r0, 0x3f	; 63
    15d8:	0f 92       	push	r0
    15da:	11 24       	eor	r1, r1
    15dc:	2f 93       	push	r18
    15de:	3f 93       	push	r19
    15e0:	4f 93       	push	r20
    15e2:	5f 93       	push	r21
    15e4:	6f 93       	push	r22
    15e6:	7f 93       	push	r23
    15e8:	8f 93       	push	r24
    15ea:	9f 93       	push	r25
    15ec:	af 93       	push	r26
    15ee:	bf 93       	push	r27
    15f0:	ef 93       	push	r30
    15f2:	ff 93       	push	r31
    15f4:	df 93       	push	r29
    15f6:	cf 93       	push	r28
    15f8:	cd b7       	in	r28, 0x3d	; 61
    15fa:	de b7       	in	r29, 0x3e	; 62
	if(g_ptr_callBack != NULL_PTR)
    15fc:	80 91 68 00 	lds	r24, 0x0068
    1600:	90 91 69 00 	lds	r25, 0x0069
    1604:	00 97       	sbiw	r24, 0x00	; 0
    1606:	71 f0       	breq	.+28     	; 0x1624 <__vector_9+0x52>
		{
		timer_ticks++;
    1608:	80 91 6a 00 	lds	r24, 0x006A
    160c:	8f 5f       	subi	r24, 0xFF	; 255
    160e:	80 93 6a 00 	sts	0x006A, r24
				if (timer_ticks==15)
    1612:	80 91 6a 00 	lds	r24, 0x006A
    1616:	8f 30       	cpi	r24, 0x0F	; 15
    1618:	29 f4       	brne	.+10     	; 0x1624 <__vector_9+0x52>
					{
			(*g_ptr_callBack)(); /* another method to call the function using pointer to function g_callBackPtr(); */
    161a:	e0 91 68 00 	lds	r30, 0x0068
    161e:	f0 91 69 00 	lds	r31, 0x0069
    1622:	09 95       	icall
					}
		}
}
    1624:	cf 91       	pop	r28
    1626:	df 91       	pop	r29
    1628:	ff 91       	pop	r31
    162a:	ef 91       	pop	r30
    162c:	bf 91       	pop	r27
    162e:	af 91       	pop	r26
    1630:	9f 91       	pop	r25
    1632:	8f 91       	pop	r24
    1634:	7f 91       	pop	r23
    1636:	6f 91       	pop	r22
    1638:	5f 91       	pop	r21
    163a:	4f 91       	pop	r20
    163c:	3f 91       	pop	r19
    163e:	2f 91       	pop	r18
    1640:	0f 90       	pop	r0
    1642:	0f be       	out	0x3f, r0	; 63
    1644:	0f 90       	pop	r0
    1646:	1f 90       	pop	r1
    1648:	18 95       	reti

0000164a <__vector_7>:

/**COMAPRE mode ISR**/
ISR(TIMER1_COMPA_vect){
    164a:	1f 92       	push	r1
    164c:	0f 92       	push	r0
    164e:	0f b6       	in	r0, 0x3f	; 63
    1650:	0f 92       	push	r0
    1652:	11 24       	eor	r1, r1
    1654:	2f 93       	push	r18
    1656:	3f 93       	push	r19
    1658:	4f 93       	push	r20
    165a:	5f 93       	push	r21
    165c:	6f 93       	push	r22
    165e:	7f 93       	push	r23
    1660:	8f 93       	push	r24
    1662:	9f 93       	push	r25
    1664:	af 93       	push	r26
    1666:	bf 93       	push	r27
    1668:	ef 93       	push	r30
    166a:	ff 93       	push	r31
    166c:	df 93       	push	r29
    166e:	cf 93       	push	r28
    1670:	cd b7       	in	r28, 0x3d	; 61
    1672:	de b7       	in	r29, 0x3e	; 62
	if(g_ptr_callBack != NULL_PTR)
    1674:	80 91 68 00 	lds	r24, 0x0068
    1678:	90 91 69 00 	lds	r25, 0x0069
    167c:	00 97       	sbiw	r24, 0x00	; 0
    167e:	81 f0       	breq	.+32     	; 0x16a0 <__vector_7+0x56>
		{
		timer_ticks++;
    1680:	80 91 6a 00 	lds	r24, 0x006A
    1684:	8f 5f       	subi	r24, 0xFF	; 255
    1686:	80 93 6a 00 	sts	0x006A, r24
		if (timer_ticks==15)
    168a:	80 91 6a 00 	lds	r24, 0x006A
    168e:	8f 30       	cpi	r24, 0x0F	; 15
    1690:	39 f4       	brne	.+14     	; 0x16a0 <__vector_7+0x56>
			{
			(*g_ptr_callBack)(); /* another method to call the function using pointer to function g_callBackPtr(); */
    1692:	e0 91 68 00 	lds	r30, 0x0068
    1696:	f0 91 69 00 	lds	r31, 0x0069
    169a:	09 95       	icall
			timer_ticks=0;
    169c:	10 92 6a 00 	sts	0x006A, r1
			}
		}
}
    16a0:	cf 91       	pop	r28
    16a2:	df 91       	pop	r29
    16a4:	ff 91       	pop	r31
    16a6:	ef 91       	pop	r30
    16a8:	bf 91       	pop	r27
    16aa:	af 91       	pop	r26
    16ac:	9f 91       	pop	r25
    16ae:	8f 91       	pop	r24
    16b0:	7f 91       	pop	r23
    16b2:	6f 91       	pop	r22
    16b4:	5f 91       	pop	r21
    16b6:	4f 91       	pop	r20
    16b8:	3f 91       	pop	r19
    16ba:	2f 91       	pop	r18
    16bc:	0f 90       	pop	r0
    16be:	0f be       	out	0x3f, r0	; 63
    16c0:	0f 90       	pop	r0
    16c2:	1f 90       	pop	r1
    16c4:	18 95       	reti

000016c6 <Timer1_init>:


void Timer1_init(const Timer1_ConfigType * Config_Ptr){
    16c6:	df 93       	push	r29
    16c8:	cf 93       	push	r28
    16ca:	00 d0       	rcall	.+0      	; 0x16cc <Timer1_init+0x6>
    16cc:	0f 92       	push	r0
    16ce:	cd b7       	in	r28, 0x3d	; 61
    16d0:	de b7       	in	r29, 0x3e	; 62
    16d2:	9b 83       	std	Y+3, r25	; 0x03
    16d4:	8a 83       	std	Y+2, r24	; 0x02
	Timer1_Mode Timer_mode;
	Timer_mode = Config_Ptr->mode;
    16d6:	ea 81       	ldd	r30, Y+2	; 0x02
    16d8:	fb 81       	ldd	r31, Y+3	; 0x03
    16da:	85 81       	ldd	r24, Z+5	; 0x05
    16dc:	89 83       	std	Y+1, r24	; 0x01
	SREG |= (1<<7);//ENABLE GLOBAL INTEREPT IN I-BIT
    16de:	af e5       	ldi	r26, 0x5F	; 95
    16e0:	b0 e0       	ldi	r27, 0x00	; 0
    16e2:	ef e5       	ldi	r30, 0x5F	; 95
    16e4:	f0 e0       	ldi	r31, 0x00	; 0
    16e6:	80 81       	ld	r24, Z
    16e8:	80 68       	ori	r24, 0x80	; 128
    16ea:	8c 93       	st	X, r24
	SET_BIT(TCCR1A,FOC1A);//used in non_pwm mode
    16ec:	af e4       	ldi	r26, 0x4F	; 79
    16ee:	b0 e0       	ldi	r27, 0x00	; 0
    16f0:	ef e4       	ldi	r30, 0x4F	; 79
    16f2:	f0 e0       	ldi	r31, 0x00	; 0
    16f4:	80 81       	ld	r24, Z
    16f6:	88 60       	ori	r24, 0x08	; 8
    16f8:	8c 93       	st	X, r24
/**SET TIMER INTIAL VALUE**/
	TCNT1=(Config_Ptr->initial_value);
    16fa:	ac e4       	ldi	r26, 0x4C	; 76
    16fc:	b0 e0       	ldi	r27, 0x00	; 0
    16fe:	ea 81       	ldd	r30, Y+2	; 0x02
    1700:	fb 81       	ldd	r31, Y+3	; 0x03
    1702:	80 81       	ld	r24, Z
    1704:	91 81       	ldd	r25, Z+1	; 0x01
    1706:	11 96       	adiw	r26, 0x01	; 1
    1708:	9c 93       	st	X, r25
    170a:	8e 93       	st	-X, r24
/**MODE**/
	if (Timer_mode == NORMAL){ // Normal mode
    170c:	89 81       	ldd	r24, Y+1	; 0x01
    170e:	88 23       	and	r24, r24
    1710:	41 f4       	brne	.+16     	; 0x1722 <Timer1_init+0x5c>
    SET_BIT(TIMSK, TOIE1); // Timer1 Overflow Interrupt is enabled.
    1712:	a9 e5       	ldi	r26, 0x59	; 89
    1714:	b0 e0       	ldi	r27, 0x00	; 0
    1716:	e9 e5       	ldi	r30, 0x59	; 89
    1718:	f0 e0       	ldi	r31, 0x00	; 0
    171a:	80 81       	ld	r24, Z
    171c:	84 60       	ori	r24, 0x04	; 4
    171e:	8c 93       	st	X, r24
    1720:	1a c0       	rjmp	.+52     	; 0x1756 <Timer1_init+0x90>
	}
	else if (Timer_mode == CTC_TOP_OCR1A){ // Compare mode
    1722:	89 81       	ldd	r24, Y+1	; 0x01
    1724:	84 30       	cpi	r24, 0x04	; 4
    1726:	b9 f4       	brne	.+46     	; 0x1756 <Timer1_init+0x90>
    SET_BIT(TCCR1B, WGM12); // Use CTC mode with OCR1A as TOP
    1728:	ae e4       	ldi	r26, 0x4E	; 78
    172a:	b0 e0       	ldi	r27, 0x00	; 0
    172c:	ee e4       	ldi	r30, 0x4E	; 78
    172e:	f0 e0       	ldi	r31, 0x00	; 0
    1730:	80 81       	ld	r24, Z
    1732:	88 60       	ori	r24, 0x08	; 8
    1734:	8c 93       	st	X, r24
    OCR1A = (Config_Ptr->compare_value); // Set compare value
    1736:	aa e4       	ldi	r26, 0x4A	; 74
    1738:	b0 e0       	ldi	r27, 0x00	; 0
    173a:	ea 81       	ldd	r30, Y+2	; 0x02
    173c:	fb 81       	ldd	r31, Y+3	; 0x03
    173e:	82 81       	ldd	r24, Z+2	; 0x02
    1740:	93 81       	ldd	r25, Z+3	; 0x03
    1742:	11 96       	adiw	r26, 0x01	; 1
    1744:	9c 93       	st	X, r25
    1746:	8e 93       	st	-X, r24
    TIMSK |= (1 << OCIE1A); // Enable Timer1 Compare A Interrupt
    1748:	a9 e5       	ldi	r26, 0x59	; 89
    174a:	b0 e0       	ldi	r27, 0x00	; 0
    174c:	e9 e5       	ldi	r30, 0x59	; 89
    174e:	f0 e0       	ldi	r31, 0x00	; 0
    1750:	80 81       	ld	r24, Z
    1752:	80 61       	ori	r24, 0x10	; 16
    1754:	8c 93       	st	X, r24
	}
/**PRE_SCALER**/
	TCCR1B=(TCCR1B&0xF8)|((Config_Ptr->prescaler)&0x8F);
    1756:	ae e4       	ldi	r26, 0x4E	; 78
    1758:	b0 e0       	ldi	r27, 0x00	; 0
    175a:	ee e4       	ldi	r30, 0x4E	; 78
    175c:	f0 e0       	ldi	r31, 0x00	; 0
    175e:	80 81       	ld	r24, Z
    1760:	98 2f       	mov	r25, r24
    1762:	98 7f       	andi	r25, 0xF8	; 248
    1764:	ea 81       	ldd	r30, Y+2	; 0x02
    1766:	fb 81       	ldd	r31, Y+3	; 0x03
    1768:	84 81       	ldd	r24, Z+4	; 0x04
    176a:	8f 78       	andi	r24, 0x8F	; 143
    176c:	89 2b       	or	r24, r25
    176e:	8c 93       	st	X, r24
}
    1770:	0f 90       	pop	r0
    1772:	0f 90       	pop	r0
    1774:	0f 90       	pop	r0
    1776:	cf 91       	pop	r28
    1778:	df 91       	pop	r29
    177a:	08 95       	ret

0000177c <Timer1_deInit>:



void Timer1_deInit(void){
    177c:	df 93       	push	r29
    177e:	cf 93       	push	r28
    1780:	cd b7       	in	r28, 0x3d	; 61
    1782:	de b7       	in	r29, 0x3e	; 62
	TCCR1B=(TCCR1B|0xF8)|((0x00)&0x8F);//No clock source (Timer/Counter stopped).
    1784:	ae e4       	ldi	r26, 0x4E	; 78
    1786:	b0 e0       	ldi	r27, 0x00	; 0
    1788:	ee e4       	ldi	r30, 0x4E	; 78
    178a:	f0 e0       	ldi	r31, 0x00	; 0
    178c:	80 81       	ld	r24, Z
    178e:	88 6f       	ori	r24, 0xF8	; 248
    1790:	8c 93       	st	X, r24
	TIMSK=0; //Disable interrupt in TIME1 module
    1792:	e9 e5       	ldi	r30, 0x59	; 89
    1794:	f0 e0       	ldi	r31, 0x00	; 0
    1796:	10 82       	st	Z, r1
}
    1798:	cf 91       	pop	r28
    179a:	df 91       	pop	r29
    179c:	08 95       	ret

0000179e <Timer1_setCallBack>:

void Timer1_setCallBack(void(*a_ptr)(void)){
    179e:	df 93       	push	r29
    17a0:	cf 93       	push	r28
    17a2:	00 d0       	rcall	.+0      	; 0x17a4 <Timer1_setCallBack+0x6>
    17a4:	cd b7       	in	r28, 0x3d	; 61
    17a6:	de b7       	in	r29, 0x3e	; 62
    17a8:	9a 83       	std	Y+2, r25	; 0x02
    17aa:	89 83       	std	Y+1, r24	; 0x01
	g_ptr_callBack = a_ptr;
    17ac:	89 81       	ldd	r24, Y+1	; 0x01
    17ae:	9a 81       	ldd	r25, Y+2	; 0x02
    17b0:	90 93 69 00 	sts	0x0069, r25
    17b4:	80 93 68 00 	sts	0x0068, r24

}
    17b8:	0f 90       	pop	r0
    17ba:	0f 90       	pop	r0
    17bc:	cf 91       	pop	r28
    17be:	df 91       	pop	r29
    17c0:	08 95       	ret

000017c2 <EEPROM_init>:
 *   - u8data: an 8-bit unsigned integer representing the data to be written.
 * Returns:
 *   - An 8-bit unsigned integer (likely indicating success or failure).
 */

void EEPROM_init(){
    17c2:	df 93       	push	r29
    17c4:	cf 93       	push	r28
    17c6:	cd b7       	in	r28, 0x3d	; 61
    17c8:	de b7       	in	r29, 0x3e	; 62
	/*CONTROL ECU act as Master with device address 10
	 *  and the used baud rate should be 400K Bits/Sec.*/
	twiConfig.address = 0x10;
    17ca:	80 e1       	ldi	r24, 0x10	; 16
    17cc:	80 93 81 00 	sts	0x0081, r24
	twiConfig.bit_rate =TWI_BaudRate_400_KB_persec;
    17d0:	81 e0       	ldi	r24, 0x01	; 1
    17d2:	80 93 82 00 	sts	0x0082, r24
	TWI_init(&twiConfig);
    17d6:	81 e8       	ldi	r24, 0x81	; 129
    17d8:	90 e0       	ldi	r25, 0x00	; 0
    17da:	0e 94 33 0a 	call	0x1466	; 0x1466 <TWI_init>
}
    17de:	cf 91       	pop	r28
    17e0:	df 91       	pop	r29
    17e2:	08 95       	ret

000017e4 <EEPROM_writeByte>:

uint8 EEPROM_writeByte(uint16 u16addr, uint8 u8data)
{
    17e4:	df 93       	push	r29
    17e6:	cf 93       	push	r28
    17e8:	00 d0       	rcall	.+0      	; 0x17ea <EEPROM_writeByte+0x6>
    17ea:	00 d0       	rcall	.+0      	; 0x17ec <EEPROM_writeByte+0x8>
    17ec:	cd b7       	in	r28, 0x3d	; 61
    17ee:	de b7       	in	r29, 0x3e	; 62
    17f0:	9a 83       	std	Y+2, r25	; 0x02
    17f2:	89 83       	std	Y+1, r24	; 0x01
    17f4:	6b 83       	std	Y+3, r22	; 0x03
	/* Send the Start Bit */
    TWI_start();
    17f6:	0e 94 82 0a 	call	0x1504	; 0x1504 <TWI_start>
    if (TWI_getStatus() != TWI_START)
    17fa:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <TWI_getStatus>
    17fe:	88 30       	cpi	r24, 0x08	; 8
    1800:	11 f0       	breq	.+4      	; 0x1806 <EEPROM_writeByte+0x22>
        return ERROR;
    1802:	1c 82       	std	Y+4, r1	; 0x04
    1804:	28 c0       	rjmp	.+80     	; 0x1856 <EEPROM_writeByte+0x72>
		
    /* Send the device address, we need to get A8 A9 A10 address bits from the
     * memory location address and R/W=0 (write) */
    TWI_writeByte((uint8)(0xA0 | ((u16addr & 0x0700)>>7)));
    1806:	89 81       	ldd	r24, Y+1	; 0x01
    1808:	9a 81       	ldd	r25, Y+2	; 0x02
    180a:	80 70       	andi	r24, 0x00	; 0
    180c:	97 70       	andi	r25, 0x07	; 7
    180e:	88 0f       	add	r24, r24
    1810:	89 2f       	mov	r24, r25
    1812:	88 1f       	adc	r24, r24
    1814:	99 0b       	sbc	r25, r25
    1816:	91 95       	neg	r25
    1818:	80 6a       	ori	r24, 0xA0	; 160
    181a:	0e 94 9d 0a 	call	0x153a	; 0x153a <TWI_writeByte>
    /*0xA0 = [1010 0000] , 0x0700=[0111 0000 0000]*/
    /*
     *
     *(u16addr & 0x0700) performs a bitwise AND operation between the memory address u16addr and the hexadecimal value 0x0700. This operation isolates the upper three bits of the memory address.
     *((u16addr & 0x0700) >> 7) shifts the result of the previous operation seven bits to the right. This effectively moves the upper three bits of the memory address to the least significant bits, preparing them to be combined with the device address.*/
    if (TWI_getStatus() != TWI_MT_SLA_W_ACK)
    181e:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <TWI_getStatus>
    1822:	88 31       	cpi	r24, 0x18	; 24
    1824:	11 f0       	breq	.+4      	; 0x182a <EEPROM_writeByte+0x46>
        return ERROR; 
    1826:	1c 82       	std	Y+4, r1	; 0x04
    1828:	16 c0       	rjmp	.+44     	; 0x1856 <EEPROM_writeByte+0x72>
     * 	 The device address is constructed by combining 0xA0[1010 0000] with the upper bits of the memory address u16addr.
     *   The upper bits are obtained by masking the address with 0x0700 and then shifting right by 7 bits.
     *   TWI_writeByte() is a function used to write a byte over the TWI bus.*/
		 
    /* Send the required memory location address */
    TWI_writeByte((uint8)(u16addr));/**Sends the memory address to specify the location in the EEPROM where data will be written.*/
    182a:	89 81       	ldd	r24, Y+1	; 0x01
    182c:	0e 94 9d 0a 	call	0x153a	; 0x153a <TWI_writeByte>
    if (TWI_getStatus() != TWI_MT_DATA_ACK)
    1830:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <TWI_getStatus>
    1834:	88 32       	cpi	r24, 0x28	; 40
    1836:	11 f0       	breq	.+4      	; 0x183c <EEPROM_writeByte+0x58>
        return ERROR;
    1838:	1c 82       	std	Y+4, r1	; 0x04
    183a:	0d c0       	rjmp	.+26     	; 0x1856 <EEPROM_writeByte+0x72>
		
    /* write byte to eeprom */
    TWI_writeByte(u8data);/** Writes the specified data byte to the specified memory address in the EEPROM*/
    183c:	8b 81       	ldd	r24, Y+3	; 0x03
    183e:	0e 94 9d 0a 	call	0x153a	; 0x153a <TWI_writeByte>
    if (TWI_getStatus() != TWI_MT_DATA_ACK)
    1842:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <TWI_getStatus>
    1846:	88 32       	cpi	r24, 0x28	; 40
    1848:	11 f0       	breq	.+4      	; 0x184e <EEPROM_writeByte+0x6a>
        return ERROR;
    184a:	1c 82       	std	Y+4, r1	; 0x04
    184c:	04 c0       	rjmp	.+8      	; 0x1856 <EEPROM_writeByte+0x72>

    /* Send the Stop Bit */
    TWI_stop();
    184e:	0e 94 92 0a 	call	0x1524	; 0x1524 <TWI_stop>
	
    return SUCCESS;
    1852:	81 e0       	ldi	r24, 0x01	; 1
    1854:	8c 83       	std	Y+4, r24	; 0x04
    1856:	8c 81       	ldd	r24, Y+4	; 0x04
}
    1858:	0f 90       	pop	r0
    185a:	0f 90       	pop	r0
    185c:	0f 90       	pop	r0
    185e:	0f 90       	pop	r0
    1860:	cf 91       	pop	r28
    1862:	df 91       	pop	r29
    1864:	08 95       	ret

00001866 <EEPROM_readByte>:

uint8 EEPROM_readByte(uint16 u16addr, uint8 *u8data)
{
    1866:	df 93       	push	r29
    1868:	cf 93       	push	r28
    186a:	00 d0       	rcall	.+0      	; 0x186c <EEPROM_readByte+0x6>
    186c:	00 d0       	rcall	.+0      	; 0x186e <EEPROM_readByte+0x8>
    186e:	0f 92       	push	r0
    1870:	cd b7       	in	r28, 0x3d	; 61
    1872:	de b7       	in	r29, 0x3e	; 62
    1874:	9a 83       	std	Y+2, r25	; 0x02
    1876:	89 83       	std	Y+1, r24	; 0x01
    1878:	7c 83       	std	Y+4, r23	; 0x04
    187a:	6b 83       	std	Y+3, r22	; 0x03
	/* Send the Start Bit */
    TWI_start();
    187c:	0e 94 82 0a 	call	0x1504	; 0x1504 <TWI_start>
    if (TWI_getStatus() != TWI_START)
    1880:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <TWI_getStatus>
    1884:	88 30       	cpi	r24, 0x08	; 8
    1886:	11 f0       	breq	.+4      	; 0x188c <EEPROM_readByte+0x26>
        return ERROR;
    1888:	1d 82       	std	Y+5, r1	; 0x05
    188a:	44 c0       	rjmp	.+136    	; 0x1914 <EEPROM_readByte+0xae>
		
    /* Send the device address, we need to get A8 A9 A10 address bits from the
     * memory location address and R/W=0 (write) */
    TWI_writeByte((uint8)((0xA0) | ((u16addr & 0x0700)>>7)));/**Sends the device address to initiate communication with the EEPROM.*/
    188c:	89 81       	ldd	r24, Y+1	; 0x01
    188e:	9a 81       	ldd	r25, Y+2	; 0x02
    1890:	80 70       	andi	r24, 0x00	; 0
    1892:	97 70       	andi	r25, 0x07	; 7
    1894:	88 0f       	add	r24, r24
    1896:	89 2f       	mov	r24, r25
    1898:	88 1f       	adc	r24, r24
    189a:	99 0b       	sbc	r25, r25
    189c:	91 95       	neg	r25
    189e:	80 6a       	ori	r24, 0xA0	; 160
    18a0:	0e 94 9d 0a 	call	0x153a	; 0x153a <TWI_writeByte>
    if (TWI_getStatus() != TWI_MT_SLA_W_ACK)
    18a4:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <TWI_getStatus>
    18a8:	88 31       	cpi	r24, 0x18	; 24
    18aa:	11 f0       	breq	.+4      	; 0x18b0 <EEPROM_readByte+0x4a>
        return ERROR;
    18ac:	1d 82       	std	Y+5, r1	; 0x05
    18ae:	32 c0       	rjmp	.+100    	; 0x1914 <EEPROM_readByte+0xae>
		
    /* Send the required memory location address */
    TWI_writeByte((uint8)(u16addr));/**ends the memory address to specify the location in the EEPROM where data will be read.*/
    18b0:	89 81       	ldd	r24, Y+1	; 0x01
    18b2:	0e 94 9d 0a 	call	0x153a	; 0x153a <TWI_writeByte>
    if (TWI_getStatus() != TWI_MT_DATA_ACK)
    18b6:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <TWI_getStatus>
    18ba:	88 32       	cpi	r24, 0x28	; 40
    18bc:	11 f0       	breq	.+4      	; 0x18c2 <EEPROM_readByte+0x5c>
        return ERROR;
    18be:	1d 82       	std	Y+5, r1	; 0x05
    18c0:	29 c0       	rjmp	.+82     	; 0x1914 <EEPROM_readByte+0xae>
		
    /* Send the Repeated Start Bit */
    TWI_start();
    18c2:	0e 94 82 0a 	call	0x1504	; 0x1504 <TWI_start>
    if (TWI_getStatus() != TWI_REP_START)
    18c6:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <TWI_getStatus>
    18ca:	80 31       	cpi	r24, 0x10	; 16
    18cc:	11 f0       	breq	.+4      	; 0x18d2 <EEPROM_readByte+0x6c>
        return ERROR;
    18ce:	1d 82       	std	Y+5, r1	; 0x05
    18d0:	21 c0       	rjmp	.+66     	; 0x1914 <EEPROM_readByte+0xae>
		
    /* Send the device address, we need to get A8 A9 A10 address bits from the
     * memory location address and R/W=1 (Read) */
    TWI_writeByte((uint8)((0xA0) | ((u16addr & 0x0700)>>7) | 1));/**Sends the device address with the read bit set to initiate reading from the specified memory address.*/
    18d2:	89 81       	ldd	r24, Y+1	; 0x01
    18d4:	9a 81       	ldd	r25, Y+2	; 0x02
    18d6:	80 70       	andi	r24, 0x00	; 0
    18d8:	97 70       	andi	r25, 0x07	; 7
    18da:	88 0f       	add	r24, r24
    18dc:	89 2f       	mov	r24, r25
    18de:	88 1f       	adc	r24, r24
    18e0:	99 0b       	sbc	r25, r25
    18e2:	91 95       	neg	r25
    18e4:	81 6a       	ori	r24, 0xA1	; 161
    18e6:	0e 94 9d 0a 	call	0x153a	; 0x153a <TWI_writeByte>
    if (TWI_getStatus() != TWI_MT_SLA_R_ACK)
    18ea:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <TWI_getStatus>
    18ee:	80 34       	cpi	r24, 0x40	; 64
    18f0:	11 f0       	breq	.+4      	; 0x18f6 <EEPROM_readByte+0x90>
        return ERROR;
    18f2:	1d 82       	std	Y+5, r1	; 0x05
    18f4:	0f c0       	rjmp	.+30     	; 0x1914 <EEPROM_readByte+0xae>

    /* Read Byte from Memory without send ACK */
    *u8data = TWI_readByteWithNACK();/**Reads the specified data byte from the specified memory address in the EEPROM.*/
    18f6:	0e 94 c7 0a 	call	0x158e	; 0x158e <TWI_readByteWithNACK>
    18fa:	eb 81       	ldd	r30, Y+3	; 0x03
    18fc:	fc 81       	ldd	r31, Y+4	; 0x04
    18fe:	80 83       	st	Z, r24
    /* By passing a pointer to a memory location rather than the actual value itself, the function can modify the content of that memory location directly.*/
    if (TWI_getStatus() != TWI_MR_DATA_NACK)
    1900:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <TWI_getStatus>
    1904:	88 35       	cpi	r24, 0x58	; 88
    1906:	11 f0       	breq	.+4      	; 0x190c <EEPROM_readByte+0xa6>
        return ERROR;
    1908:	1d 82       	std	Y+5, r1	; 0x05
    190a:	04 c0       	rjmp	.+8      	; 0x1914 <EEPROM_readByte+0xae>

    /* Send the Stop Bit */
    TWI_stop();
    190c:	0e 94 92 0a 	call	0x1524	; 0x1524 <TWI_stop>

    return SUCCESS;
    1910:	81 e0       	ldi	r24, 0x01	; 1
    1912:	8d 83       	std	Y+5, r24	; 0x05
    1914:	8d 81       	ldd	r24, Y+5	; 0x05
}
    1916:	0f 90       	pop	r0
    1918:	0f 90       	pop	r0
    191a:	0f 90       	pop	r0
    191c:	0f 90       	pop	r0
    191e:	0f 90       	pop	r0
    1920:	cf 91       	pop	r28
    1922:	df 91       	pop	r29
    1924:	08 95       	ret

00001926 <GPIO_setupPinDirection>:
 * Description :
 * Setup the direction of the required pin input/output.
 * If the input port number or pin number are not correct, The function will not handle the request.
 */
void GPIO_setupPinDirection(uint8 port_num, uint8 pin_num, GPIO_PinDirectionType direction)
{
    1926:	df 93       	push	r29
    1928:	cf 93       	push	r28
    192a:	00 d0       	rcall	.+0      	; 0x192c <GPIO_setupPinDirection+0x6>
    192c:	00 d0       	rcall	.+0      	; 0x192e <GPIO_setupPinDirection+0x8>
    192e:	0f 92       	push	r0
    1930:	cd b7       	in	r28, 0x3d	; 61
    1932:	de b7       	in	r29, 0x3e	; 62
    1934:	89 83       	std	Y+1, r24	; 0x01
    1936:	6a 83       	std	Y+2, r22	; 0x02
    1938:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    193a:	8a 81       	ldd	r24, Y+2	; 0x02
    193c:	88 30       	cpi	r24, 0x08	; 8
    193e:	08 f0       	brcs	.+2      	; 0x1942 <GPIO_setupPinDirection+0x1c>
    1940:	d5 c0       	rjmp	.+426    	; 0x1aec <GPIO_setupPinDirection+0x1c6>
    1942:	89 81       	ldd	r24, Y+1	; 0x01
    1944:	84 30       	cpi	r24, 0x04	; 4
    1946:	08 f0       	brcs	.+2      	; 0x194a <GPIO_setupPinDirection+0x24>
    1948:	d1 c0       	rjmp	.+418    	; 0x1aec <GPIO_setupPinDirection+0x1c6>
		/* Do Nothing */
	}
	else
	{
		/* Setup the pin direction as required */
		switch(port_num)
    194a:	89 81       	ldd	r24, Y+1	; 0x01
    194c:	28 2f       	mov	r18, r24
    194e:	30 e0       	ldi	r19, 0x00	; 0
    1950:	3d 83       	std	Y+5, r19	; 0x05
    1952:	2c 83       	std	Y+4, r18	; 0x04
    1954:	8c 81       	ldd	r24, Y+4	; 0x04
    1956:	9d 81       	ldd	r25, Y+5	; 0x05
    1958:	81 30       	cpi	r24, 0x01	; 1
    195a:	91 05       	cpc	r25, r1
    195c:	09 f4       	brne	.+2      	; 0x1960 <GPIO_setupPinDirection+0x3a>
    195e:	43 c0       	rjmp	.+134    	; 0x19e6 <GPIO_setupPinDirection+0xc0>
    1960:	2c 81       	ldd	r18, Y+4	; 0x04
    1962:	3d 81       	ldd	r19, Y+5	; 0x05
    1964:	22 30       	cpi	r18, 0x02	; 2
    1966:	31 05       	cpc	r19, r1
    1968:	2c f4       	brge	.+10     	; 0x1974 <GPIO_setupPinDirection+0x4e>
    196a:	8c 81       	ldd	r24, Y+4	; 0x04
    196c:	9d 81       	ldd	r25, Y+5	; 0x05
    196e:	00 97       	sbiw	r24, 0x00	; 0
    1970:	71 f0       	breq	.+28     	; 0x198e <GPIO_setupPinDirection+0x68>
    1972:	bc c0       	rjmp	.+376    	; 0x1aec <GPIO_setupPinDirection+0x1c6>
    1974:	2c 81       	ldd	r18, Y+4	; 0x04
    1976:	3d 81       	ldd	r19, Y+5	; 0x05
    1978:	22 30       	cpi	r18, 0x02	; 2
    197a:	31 05       	cpc	r19, r1
    197c:	09 f4       	brne	.+2      	; 0x1980 <GPIO_setupPinDirection+0x5a>
    197e:	5f c0       	rjmp	.+190    	; 0x1a3e <GPIO_setupPinDirection+0x118>
    1980:	8c 81       	ldd	r24, Y+4	; 0x04
    1982:	9d 81       	ldd	r25, Y+5	; 0x05
    1984:	83 30       	cpi	r24, 0x03	; 3
    1986:	91 05       	cpc	r25, r1
    1988:	09 f4       	brne	.+2      	; 0x198c <GPIO_setupPinDirection+0x66>
    198a:	85 c0       	rjmp	.+266    	; 0x1a96 <GPIO_setupPinDirection+0x170>
    198c:	af c0       	rjmp	.+350    	; 0x1aec <GPIO_setupPinDirection+0x1c6>
		{
		case PORTA_ID:
			if(direction == PIN_OUTPUT)
    198e:	8b 81       	ldd	r24, Y+3	; 0x03
    1990:	81 30       	cpi	r24, 0x01	; 1
    1992:	a1 f4       	brne	.+40     	; 0x19bc <GPIO_setupPinDirection+0x96>
			{
				SET_BIT(DDRA,pin_num);
    1994:	aa e3       	ldi	r26, 0x3A	; 58
    1996:	b0 e0       	ldi	r27, 0x00	; 0
    1998:	ea e3       	ldi	r30, 0x3A	; 58
    199a:	f0 e0       	ldi	r31, 0x00	; 0
    199c:	80 81       	ld	r24, Z
    199e:	48 2f       	mov	r20, r24
    19a0:	8a 81       	ldd	r24, Y+2	; 0x02
    19a2:	28 2f       	mov	r18, r24
    19a4:	30 e0       	ldi	r19, 0x00	; 0
    19a6:	81 e0       	ldi	r24, 0x01	; 1
    19a8:	90 e0       	ldi	r25, 0x00	; 0
    19aa:	02 2e       	mov	r0, r18
    19ac:	02 c0       	rjmp	.+4      	; 0x19b2 <GPIO_setupPinDirection+0x8c>
    19ae:	88 0f       	add	r24, r24
    19b0:	99 1f       	adc	r25, r25
    19b2:	0a 94       	dec	r0
    19b4:	e2 f7       	brpl	.-8      	; 0x19ae <GPIO_setupPinDirection+0x88>
    19b6:	84 2b       	or	r24, r20
    19b8:	8c 93       	st	X, r24
    19ba:	98 c0       	rjmp	.+304    	; 0x1aec <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRA,pin_num);
    19bc:	aa e3       	ldi	r26, 0x3A	; 58
    19be:	b0 e0       	ldi	r27, 0x00	; 0
    19c0:	ea e3       	ldi	r30, 0x3A	; 58
    19c2:	f0 e0       	ldi	r31, 0x00	; 0
    19c4:	80 81       	ld	r24, Z
    19c6:	48 2f       	mov	r20, r24
    19c8:	8a 81       	ldd	r24, Y+2	; 0x02
    19ca:	28 2f       	mov	r18, r24
    19cc:	30 e0       	ldi	r19, 0x00	; 0
    19ce:	81 e0       	ldi	r24, 0x01	; 1
    19d0:	90 e0       	ldi	r25, 0x00	; 0
    19d2:	02 2e       	mov	r0, r18
    19d4:	02 c0       	rjmp	.+4      	; 0x19da <GPIO_setupPinDirection+0xb4>
    19d6:	88 0f       	add	r24, r24
    19d8:	99 1f       	adc	r25, r25
    19da:	0a 94       	dec	r0
    19dc:	e2 f7       	brpl	.-8      	; 0x19d6 <GPIO_setupPinDirection+0xb0>
    19de:	80 95       	com	r24
    19e0:	84 23       	and	r24, r20
    19e2:	8c 93       	st	X, r24
    19e4:	83 c0       	rjmp	.+262    	; 0x1aec <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTB_ID:
			if(direction == PIN_OUTPUT)
    19e6:	8b 81       	ldd	r24, Y+3	; 0x03
    19e8:	81 30       	cpi	r24, 0x01	; 1
    19ea:	a1 f4       	brne	.+40     	; 0x1a14 <GPIO_setupPinDirection+0xee>
			{
				SET_BIT(DDRB,pin_num);
    19ec:	a7 e3       	ldi	r26, 0x37	; 55
    19ee:	b0 e0       	ldi	r27, 0x00	; 0
    19f0:	e7 e3       	ldi	r30, 0x37	; 55
    19f2:	f0 e0       	ldi	r31, 0x00	; 0
    19f4:	80 81       	ld	r24, Z
    19f6:	48 2f       	mov	r20, r24
    19f8:	8a 81       	ldd	r24, Y+2	; 0x02
    19fa:	28 2f       	mov	r18, r24
    19fc:	30 e0       	ldi	r19, 0x00	; 0
    19fe:	81 e0       	ldi	r24, 0x01	; 1
    1a00:	90 e0       	ldi	r25, 0x00	; 0
    1a02:	02 2e       	mov	r0, r18
    1a04:	02 c0       	rjmp	.+4      	; 0x1a0a <GPIO_setupPinDirection+0xe4>
    1a06:	88 0f       	add	r24, r24
    1a08:	99 1f       	adc	r25, r25
    1a0a:	0a 94       	dec	r0
    1a0c:	e2 f7       	brpl	.-8      	; 0x1a06 <GPIO_setupPinDirection+0xe0>
    1a0e:	84 2b       	or	r24, r20
    1a10:	8c 93       	st	X, r24
    1a12:	6c c0       	rjmp	.+216    	; 0x1aec <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRB,pin_num);
    1a14:	a7 e3       	ldi	r26, 0x37	; 55
    1a16:	b0 e0       	ldi	r27, 0x00	; 0
    1a18:	e7 e3       	ldi	r30, 0x37	; 55
    1a1a:	f0 e0       	ldi	r31, 0x00	; 0
    1a1c:	80 81       	ld	r24, Z
    1a1e:	48 2f       	mov	r20, r24
    1a20:	8a 81       	ldd	r24, Y+2	; 0x02
    1a22:	28 2f       	mov	r18, r24
    1a24:	30 e0       	ldi	r19, 0x00	; 0
    1a26:	81 e0       	ldi	r24, 0x01	; 1
    1a28:	90 e0       	ldi	r25, 0x00	; 0
    1a2a:	02 2e       	mov	r0, r18
    1a2c:	02 c0       	rjmp	.+4      	; 0x1a32 <GPIO_setupPinDirection+0x10c>
    1a2e:	88 0f       	add	r24, r24
    1a30:	99 1f       	adc	r25, r25
    1a32:	0a 94       	dec	r0
    1a34:	e2 f7       	brpl	.-8      	; 0x1a2e <GPIO_setupPinDirection+0x108>
    1a36:	80 95       	com	r24
    1a38:	84 23       	and	r24, r20
    1a3a:	8c 93       	st	X, r24
    1a3c:	57 c0       	rjmp	.+174    	; 0x1aec <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTC_ID:
			if(direction == PIN_OUTPUT)
    1a3e:	8b 81       	ldd	r24, Y+3	; 0x03
    1a40:	81 30       	cpi	r24, 0x01	; 1
    1a42:	a1 f4       	brne	.+40     	; 0x1a6c <GPIO_setupPinDirection+0x146>
			{
				SET_BIT(DDRC,pin_num);
    1a44:	a4 e3       	ldi	r26, 0x34	; 52
    1a46:	b0 e0       	ldi	r27, 0x00	; 0
    1a48:	e4 e3       	ldi	r30, 0x34	; 52
    1a4a:	f0 e0       	ldi	r31, 0x00	; 0
    1a4c:	80 81       	ld	r24, Z
    1a4e:	48 2f       	mov	r20, r24
    1a50:	8a 81       	ldd	r24, Y+2	; 0x02
    1a52:	28 2f       	mov	r18, r24
    1a54:	30 e0       	ldi	r19, 0x00	; 0
    1a56:	81 e0       	ldi	r24, 0x01	; 1
    1a58:	90 e0       	ldi	r25, 0x00	; 0
    1a5a:	02 2e       	mov	r0, r18
    1a5c:	02 c0       	rjmp	.+4      	; 0x1a62 <GPIO_setupPinDirection+0x13c>
    1a5e:	88 0f       	add	r24, r24
    1a60:	99 1f       	adc	r25, r25
    1a62:	0a 94       	dec	r0
    1a64:	e2 f7       	brpl	.-8      	; 0x1a5e <GPIO_setupPinDirection+0x138>
    1a66:	84 2b       	or	r24, r20
    1a68:	8c 93       	st	X, r24
    1a6a:	40 c0       	rjmp	.+128    	; 0x1aec <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRC,pin_num);
    1a6c:	a4 e3       	ldi	r26, 0x34	; 52
    1a6e:	b0 e0       	ldi	r27, 0x00	; 0
    1a70:	e4 e3       	ldi	r30, 0x34	; 52
    1a72:	f0 e0       	ldi	r31, 0x00	; 0
    1a74:	80 81       	ld	r24, Z
    1a76:	48 2f       	mov	r20, r24
    1a78:	8a 81       	ldd	r24, Y+2	; 0x02
    1a7a:	28 2f       	mov	r18, r24
    1a7c:	30 e0       	ldi	r19, 0x00	; 0
    1a7e:	81 e0       	ldi	r24, 0x01	; 1
    1a80:	90 e0       	ldi	r25, 0x00	; 0
    1a82:	02 2e       	mov	r0, r18
    1a84:	02 c0       	rjmp	.+4      	; 0x1a8a <GPIO_setupPinDirection+0x164>
    1a86:	88 0f       	add	r24, r24
    1a88:	99 1f       	adc	r25, r25
    1a8a:	0a 94       	dec	r0
    1a8c:	e2 f7       	brpl	.-8      	; 0x1a86 <GPIO_setupPinDirection+0x160>
    1a8e:	80 95       	com	r24
    1a90:	84 23       	and	r24, r20
    1a92:	8c 93       	st	X, r24
    1a94:	2b c0       	rjmp	.+86     	; 0x1aec <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTD_ID:
			if(direction == PIN_OUTPUT)
    1a96:	8b 81       	ldd	r24, Y+3	; 0x03
    1a98:	81 30       	cpi	r24, 0x01	; 1
    1a9a:	a1 f4       	brne	.+40     	; 0x1ac4 <GPIO_setupPinDirection+0x19e>
			{
				SET_BIT(DDRD,pin_num);
    1a9c:	a1 e3       	ldi	r26, 0x31	; 49
    1a9e:	b0 e0       	ldi	r27, 0x00	; 0
    1aa0:	e1 e3       	ldi	r30, 0x31	; 49
    1aa2:	f0 e0       	ldi	r31, 0x00	; 0
    1aa4:	80 81       	ld	r24, Z
    1aa6:	48 2f       	mov	r20, r24
    1aa8:	8a 81       	ldd	r24, Y+2	; 0x02
    1aaa:	28 2f       	mov	r18, r24
    1aac:	30 e0       	ldi	r19, 0x00	; 0
    1aae:	81 e0       	ldi	r24, 0x01	; 1
    1ab0:	90 e0       	ldi	r25, 0x00	; 0
    1ab2:	02 2e       	mov	r0, r18
    1ab4:	02 c0       	rjmp	.+4      	; 0x1aba <GPIO_setupPinDirection+0x194>
    1ab6:	88 0f       	add	r24, r24
    1ab8:	99 1f       	adc	r25, r25
    1aba:	0a 94       	dec	r0
    1abc:	e2 f7       	brpl	.-8      	; 0x1ab6 <GPIO_setupPinDirection+0x190>
    1abe:	84 2b       	or	r24, r20
    1ac0:	8c 93       	st	X, r24
    1ac2:	14 c0       	rjmp	.+40     	; 0x1aec <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRD,pin_num);
    1ac4:	a1 e3       	ldi	r26, 0x31	; 49
    1ac6:	b0 e0       	ldi	r27, 0x00	; 0
    1ac8:	e1 e3       	ldi	r30, 0x31	; 49
    1aca:	f0 e0       	ldi	r31, 0x00	; 0
    1acc:	80 81       	ld	r24, Z
    1ace:	48 2f       	mov	r20, r24
    1ad0:	8a 81       	ldd	r24, Y+2	; 0x02
    1ad2:	28 2f       	mov	r18, r24
    1ad4:	30 e0       	ldi	r19, 0x00	; 0
    1ad6:	81 e0       	ldi	r24, 0x01	; 1
    1ad8:	90 e0       	ldi	r25, 0x00	; 0
    1ada:	02 2e       	mov	r0, r18
    1adc:	02 c0       	rjmp	.+4      	; 0x1ae2 <GPIO_setupPinDirection+0x1bc>
    1ade:	88 0f       	add	r24, r24
    1ae0:	99 1f       	adc	r25, r25
    1ae2:	0a 94       	dec	r0
    1ae4:	e2 f7       	brpl	.-8      	; 0x1ade <GPIO_setupPinDirection+0x1b8>
    1ae6:	80 95       	com	r24
    1ae8:	84 23       	and	r24, r20
    1aea:	8c 93       	st	X, r24
			}
			break;
		}
	}
}
    1aec:	0f 90       	pop	r0
    1aee:	0f 90       	pop	r0
    1af0:	0f 90       	pop	r0
    1af2:	0f 90       	pop	r0
    1af4:	0f 90       	pop	r0
    1af6:	cf 91       	pop	r28
    1af8:	df 91       	pop	r29
    1afa:	08 95       	ret

00001afc <GPIO_writePin>:
 * Write the value Logic High or Logic Low on the required pin.
 * If the input port number or pin number are not correct, The function will not handle the request.
 * If the pin is input, this function will enable/disable the internal pull-up resistor.
 */
void GPIO_writePin(uint8 port_num, uint8 pin_num, uint8 value)
{
    1afc:	df 93       	push	r29
    1afe:	cf 93       	push	r28
    1b00:	00 d0       	rcall	.+0      	; 0x1b02 <GPIO_writePin+0x6>
    1b02:	00 d0       	rcall	.+0      	; 0x1b04 <GPIO_writePin+0x8>
    1b04:	0f 92       	push	r0
    1b06:	cd b7       	in	r28, 0x3d	; 61
    1b08:	de b7       	in	r29, 0x3e	; 62
    1b0a:	89 83       	std	Y+1, r24	; 0x01
    1b0c:	6a 83       	std	Y+2, r22	; 0x02
    1b0e:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    1b10:	8a 81       	ldd	r24, Y+2	; 0x02
    1b12:	88 30       	cpi	r24, 0x08	; 8
    1b14:	08 f0       	brcs	.+2      	; 0x1b18 <GPIO_writePin+0x1c>
    1b16:	d5 c0       	rjmp	.+426    	; 0x1cc2 <GPIO_writePin+0x1c6>
    1b18:	89 81       	ldd	r24, Y+1	; 0x01
    1b1a:	84 30       	cpi	r24, 0x04	; 4
    1b1c:	08 f0       	brcs	.+2      	; 0x1b20 <GPIO_writePin+0x24>
    1b1e:	d1 c0       	rjmp	.+418    	; 0x1cc2 <GPIO_writePin+0x1c6>
		/* Do Nothing */
	}
	else
	{
		/* Write the pin value as required */
		switch(port_num)
    1b20:	89 81       	ldd	r24, Y+1	; 0x01
    1b22:	28 2f       	mov	r18, r24
    1b24:	30 e0       	ldi	r19, 0x00	; 0
    1b26:	3d 83       	std	Y+5, r19	; 0x05
    1b28:	2c 83       	std	Y+4, r18	; 0x04
    1b2a:	8c 81       	ldd	r24, Y+4	; 0x04
    1b2c:	9d 81       	ldd	r25, Y+5	; 0x05
    1b2e:	81 30       	cpi	r24, 0x01	; 1
    1b30:	91 05       	cpc	r25, r1
    1b32:	09 f4       	brne	.+2      	; 0x1b36 <GPIO_writePin+0x3a>
    1b34:	43 c0       	rjmp	.+134    	; 0x1bbc <GPIO_writePin+0xc0>
    1b36:	2c 81       	ldd	r18, Y+4	; 0x04
    1b38:	3d 81       	ldd	r19, Y+5	; 0x05
    1b3a:	22 30       	cpi	r18, 0x02	; 2
    1b3c:	31 05       	cpc	r19, r1
    1b3e:	2c f4       	brge	.+10     	; 0x1b4a <GPIO_writePin+0x4e>
    1b40:	8c 81       	ldd	r24, Y+4	; 0x04
    1b42:	9d 81       	ldd	r25, Y+5	; 0x05
    1b44:	00 97       	sbiw	r24, 0x00	; 0
    1b46:	71 f0       	breq	.+28     	; 0x1b64 <GPIO_writePin+0x68>
    1b48:	bc c0       	rjmp	.+376    	; 0x1cc2 <GPIO_writePin+0x1c6>
    1b4a:	2c 81       	ldd	r18, Y+4	; 0x04
    1b4c:	3d 81       	ldd	r19, Y+5	; 0x05
    1b4e:	22 30       	cpi	r18, 0x02	; 2
    1b50:	31 05       	cpc	r19, r1
    1b52:	09 f4       	brne	.+2      	; 0x1b56 <GPIO_writePin+0x5a>
    1b54:	5f c0       	rjmp	.+190    	; 0x1c14 <GPIO_writePin+0x118>
    1b56:	8c 81       	ldd	r24, Y+4	; 0x04
    1b58:	9d 81       	ldd	r25, Y+5	; 0x05
    1b5a:	83 30       	cpi	r24, 0x03	; 3
    1b5c:	91 05       	cpc	r25, r1
    1b5e:	09 f4       	brne	.+2      	; 0x1b62 <GPIO_writePin+0x66>
    1b60:	85 c0       	rjmp	.+266    	; 0x1c6c <GPIO_writePin+0x170>
    1b62:	af c0       	rjmp	.+350    	; 0x1cc2 <GPIO_writePin+0x1c6>
		{
		case PORTA_ID:
			if(value == LOGIC_HIGH)
    1b64:	8b 81       	ldd	r24, Y+3	; 0x03
    1b66:	81 30       	cpi	r24, 0x01	; 1
    1b68:	a1 f4       	brne	.+40     	; 0x1b92 <GPIO_writePin+0x96>
			{
				SET_BIT(PORTA,pin_num);
    1b6a:	ab e3       	ldi	r26, 0x3B	; 59
    1b6c:	b0 e0       	ldi	r27, 0x00	; 0
    1b6e:	eb e3       	ldi	r30, 0x3B	; 59
    1b70:	f0 e0       	ldi	r31, 0x00	; 0
    1b72:	80 81       	ld	r24, Z
    1b74:	48 2f       	mov	r20, r24
    1b76:	8a 81       	ldd	r24, Y+2	; 0x02
    1b78:	28 2f       	mov	r18, r24
    1b7a:	30 e0       	ldi	r19, 0x00	; 0
    1b7c:	81 e0       	ldi	r24, 0x01	; 1
    1b7e:	90 e0       	ldi	r25, 0x00	; 0
    1b80:	02 2e       	mov	r0, r18
    1b82:	02 c0       	rjmp	.+4      	; 0x1b88 <GPIO_writePin+0x8c>
    1b84:	88 0f       	add	r24, r24
    1b86:	99 1f       	adc	r25, r25
    1b88:	0a 94       	dec	r0
    1b8a:	e2 f7       	brpl	.-8      	; 0x1b84 <GPIO_writePin+0x88>
    1b8c:	84 2b       	or	r24, r20
    1b8e:	8c 93       	st	X, r24
    1b90:	98 c0       	rjmp	.+304    	; 0x1cc2 <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTA,pin_num);
    1b92:	ab e3       	ldi	r26, 0x3B	; 59
    1b94:	b0 e0       	ldi	r27, 0x00	; 0
    1b96:	eb e3       	ldi	r30, 0x3B	; 59
    1b98:	f0 e0       	ldi	r31, 0x00	; 0
    1b9a:	80 81       	ld	r24, Z
    1b9c:	48 2f       	mov	r20, r24
    1b9e:	8a 81       	ldd	r24, Y+2	; 0x02
    1ba0:	28 2f       	mov	r18, r24
    1ba2:	30 e0       	ldi	r19, 0x00	; 0
    1ba4:	81 e0       	ldi	r24, 0x01	; 1
    1ba6:	90 e0       	ldi	r25, 0x00	; 0
    1ba8:	02 2e       	mov	r0, r18
    1baa:	02 c0       	rjmp	.+4      	; 0x1bb0 <GPIO_writePin+0xb4>
    1bac:	88 0f       	add	r24, r24
    1bae:	99 1f       	adc	r25, r25
    1bb0:	0a 94       	dec	r0
    1bb2:	e2 f7       	brpl	.-8      	; 0x1bac <GPIO_writePin+0xb0>
    1bb4:	80 95       	com	r24
    1bb6:	84 23       	and	r24, r20
    1bb8:	8c 93       	st	X, r24
    1bba:	83 c0       	rjmp	.+262    	; 0x1cc2 <GPIO_writePin+0x1c6>
			}
			break;
		case PORTB_ID:
			if(value == LOGIC_HIGH)
    1bbc:	8b 81       	ldd	r24, Y+3	; 0x03
    1bbe:	81 30       	cpi	r24, 0x01	; 1
    1bc0:	a1 f4       	brne	.+40     	; 0x1bea <GPIO_writePin+0xee>
			{
				SET_BIT(PORTB,pin_num);
    1bc2:	a8 e3       	ldi	r26, 0x38	; 56
    1bc4:	b0 e0       	ldi	r27, 0x00	; 0
    1bc6:	e8 e3       	ldi	r30, 0x38	; 56
    1bc8:	f0 e0       	ldi	r31, 0x00	; 0
    1bca:	80 81       	ld	r24, Z
    1bcc:	48 2f       	mov	r20, r24
    1bce:	8a 81       	ldd	r24, Y+2	; 0x02
    1bd0:	28 2f       	mov	r18, r24
    1bd2:	30 e0       	ldi	r19, 0x00	; 0
    1bd4:	81 e0       	ldi	r24, 0x01	; 1
    1bd6:	90 e0       	ldi	r25, 0x00	; 0
    1bd8:	02 2e       	mov	r0, r18
    1bda:	02 c0       	rjmp	.+4      	; 0x1be0 <GPIO_writePin+0xe4>
    1bdc:	88 0f       	add	r24, r24
    1bde:	99 1f       	adc	r25, r25
    1be0:	0a 94       	dec	r0
    1be2:	e2 f7       	brpl	.-8      	; 0x1bdc <GPIO_writePin+0xe0>
    1be4:	84 2b       	or	r24, r20
    1be6:	8c 93       	st	X, r24
    1be8:	6c c0       	rjmp	.+216    	; 0x1cc2 <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTB,pin_num);
    1bea:	a8 e3       	ldi	r26, 0x38	; 56
    1bec:	b0 e0       	ldi	r27, 0x00	; 0
    1bee:	e8 e3       	ldi	r30, 0x38	; 56
    1bf0:	f0 e0       	ldi	r31, 0x00	; 0
    1bf2:	80 81       	ld	r24, Z
    1bf4:	48 2f       	mov	r20, r24
    1bf6:	8a 81       	ldd	r24, Y+2	; 0x02
    1bf8:	28 2f       	mov	r18, r24
    1bfa:	30 e0       	ldi	r19, 0x00	; 0
    1bfc:	81 e0       	ldi	r24, 0x01	; 1
    1bfe:	90 e0       	ldi	r25, 0x00	; 0
    1c00:	02 2e       	mov	r0, r18
    1c02:	02 c0       	rjmp	.+4      	; 0x1c08 <GPIO_writePin+0x10c>
    1c04:	88 0f       	add	r24, r24
    1c06:	99 1f       	adc	r25, r25
    1c08:	0a 94       	dec	r0
    1c0a:	e2 f7       	brpl	.-8      	; 0x1c04 <GPIO_writePin+0x108>
    1c0c:	80 95       	com	r24
    1c0e:	84 23       	and	r24, r20
    1c10:	8c 93       	st	X, r24
    1c12:	57 c0       	rjmp	.+174    	; 0x1cc2 <GPIO_writePin+0x1c6>
			}
			break;
		case PORTC_ID:
			if(value == LOGIC_HIGH)
    1c14:	8b 81       	ldd	r24, Y+3	; 0x03
    1c16:	81 30       	cpi	r24, 0x01	; 1
    1c18:	a1 f4       	brne	.+40     	; 0x1c42 <GPIO_writePin+0x146>
			{
				SET_BIT(PORTC,pin_num);
    1c1a:	a5 e3       	ldi	r26, 0x35	; 53
    1c1c:	b0 e0       	ldi	r27, 0x00	; 0
    1c1e:	e5 e3       	ldi	r30, 0x35	; 53
    1c20:	f0 e0       	ldi	r31, 0x00	; 0
    1c22:	80 81       	ld	r24, Z
    1c24:	48 2f       	mov	r20, r24
    1c26:	8a 81       	ldd	r24, Y+2	; 0x02
    1c28:	28 2f       	mov	r18, r24
    1c2a:	30 e0       	ldi	r19, 0x00	; 0
    1c2c:	81 e0       	ldi	r24, 0x01	; 1
    1c2e:	90 e0       	ldi	r25, 0x00	; 0
    1c30:	02 2e       	mov	r0, r18
    1c32:	02 c0       	rjmp	.+4      	; 0x1c38 <GPIO_writePin+0x13c>
    1c34:	88 0f       	add	r24, r24
    1c36:	99 1f       	adc	r25, r25
    1c38:	0a 94       	dec	r0
    1c3a:	e2 f7       	brpl	.-8      	; 0x1c34 <GPIO_writePin+0x138>
    1c3c:	84 2b       	or	r24, r20
    1c3e:	8c 93       	st	X, r24
    1c40:	40 c0       	rjmp	.+128    	; 0x1cc2 <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTC,pin_num);
    1c42:	a5 e3       	ldi	r26, 0x35	; 53
    1c44:	b0 e0       	ldi	r27, 0x00	; 0
    1c46:	e5 e3       	ldi	r30, 0x35	; 53
    1c48:	f0 e0       	ldi	r31, 0x00	; 0
    1c4a:	80 81       	ld	r24, Z
    1c4c:	48 2f       	mov	r20, r24
    1c4e:	8a 81       	ldd	r24, Y+2	; 0x02
    1c50:	28 2f       	mov	r18, r24
    1c52:	30 e0       	ldi	r19, 0x00	; 0
    1c54:	81 e0       	ldi	r24, 0x01	; 1
    1c56:	90 e0       	ldi	r25, 0x00	; 0
    1c58:	02 2e       	mov	r0, r18
    1c5a:	02 c0       	rjmp	.+4      	; 0x1c60 <GPIO_writePin+0x164>
    1c5c:	88 0f       	add	r24, r24
    1c5e:	99 1f       	adc	r25, r25
    1c60:	0a 94       	dec	r0
    1c62:	e2 f7       	brpl	.-8      	; 0x1c5c <GPIO_writePin+0x160>
    1c64:	80 95       	com	r24
    1c66:	84 23       	and	r24, r20
    1c68:	8c 93       	st	X, r24
    1c6a:	2b c0       	rjmp	.+86     	; 0x1cc2 <GPIO_writePin+0x1c6>
			}
			break;
		case PORTD_ID:
			if(value == LOGIC_HIGH)
    1c6c:	8b 81       	ldd	r24, Y+3	; 0x03
    1c6e:	81 30       	cpi	r24, 0x01	; 1
    1c70:	a1 f4       	brne	.+40     	; 0x1c9a <GPIO_writePin+0x19e>
			{
				SET_BIT(PORTD,pin_num);
    1c72:	a2 e3       	ldi	r26, 0x32	; 50
    1c74:	b0 e0       	ldi	r27, 0x00	; 0
    1c76:	e2 e3       	ldi	r30, 0x32	; 50
    1c78:	f0 e0       	ldi	r31, 0x00	; 0
    1c7a:	80 81       	ld	r24, Z
    1c7c:	48 2f       	mov	r20, r24
    1c7e:	8a 81       	ldd	r24, Y+2	; 0x02
    1c80:	28 2f       	mov	r18, r24
    1c82:	30 e0       	ldi	r19, 0x00	; 0
    1c84:	81 e0       	ldi	r24, 0x01	; 1
    1c86:	90 e0       	ldi	r25, 0x00	; 0
    1c88:	02 2e       	mov	r0, r18
    1c8a:	02 c0       	rjmp	.+4      	; 0x1c90 <GPIO_writePin+0x194>
    1c8c:	88 0f       	add	r24, r24
    1c8e:	99 1f       	adc	r25, r25
    1c90:	0a 94       	dec	r0
    1c92:	e2 f7       	brpl	.-8      	; 0x1c8c <GPIO_writePin+0x190>
    1c94:	84 2b       	or	r24, r20
    1c96:	8c 93       	st	X, r24
    1c98:	14 c0       	rjmp	.+40     	; 0x1cc2 <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTD,pin_num);
    1c9a:	a2 e3       	ldi	r26, 0x32	; 50
    1c9c:	b0 e0       	ldi	r27, 0x00	; 0
    1c9e:	e2 e3       	ldi	r30, 0x32	; 50
    1ca0:	f0 e0       	ldi	r31, 0x00	; 0
    1ca2:	80 81       	ld	r24, Z
    1ca4:	48 2f       	mov	r20, r24
    1ca6:	8a 81       	ldd	r24, Y+2	; 0x02
    1ca8:	28 2f       	mov	r18, r24
    1caa:	30 e0       	ldi	r19, 0x00	; 0
    1cac:	81 e0       	ldi	r24, 0x01	; 1
    1cae:	90 e0       	ldi	r25, 0x00	; 0
    1cb0:	02 2e       	mov	r0, r18
    1cb2:	02 c0       	rjmp	.+4      	; 0x1cb8 <GPIO_writePin+0x1bc>
    1cb4:	88 0f       	add	r24, r24
    1cb6:	99 1f       	adc	r25, r25
    1cb8:	0a 94       	dec	r0
    1cba:	e2 f7       	brpl	.-8      	; 0x1cb4 <GPIO_writePin+0x1b8>
    1cbc:	80 95       	com	r24
    1cbe:	84 23       	and	r24, r20
    1cc0:	8c 93       	st	X, r24
			}
			break;
		}
	}
}
    1cc2:	0f 90       	pop	r0
    1cc4:	0f 90       	pop	r0
    1cc6:	0f 90       	pop	r0
    1cc8:	0f 90       	pop	r0
    1cca:	0f 90       	pop	r0
    1ccc:	cf 91       	pop	r28
    1cce:	df 91       	pop	r29
    1cd0:	08 95       	ret

00001cd2 <GPIO_readPin>:
 * Description :
 * Read and return the value for the required pin, it should be Logic High or Logic Low.
 * If the input port number or pin number are not correct, The function will return Logic Low.
 */
uint8 GPIO_readPin(uint8 port_num, uint8 pin_num)
{
    1cd2:	df 93       	push	r29
    1cd4:	cf 93       	push	r28
    1cd6:	00 d0       	rcall	.+0      	; 0x1cd8 <GPIO_readPin+0x6>
    1cd8:	00 d0       	rcall	.+0      	; 0x1cda <GPIO_readPin+0x8>
    1cda:	0f 92       	push	r0
    1cdc:	cd b7       	in	r28, 0x3d	; 61
    1cde:	de b7       	in	r29, 0x3e	; 62
    1ce0:	8a 83       	std	Y+2, r24	; 0x02
    1ce2:	6b 83       	std	Y+3, r22	; 0x03
	uint8 pin_value = LOGIC_LOW;
    1ce4:	19 82       	std	Y+1, r1	; 0x01
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    1ce6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ce8:	88 30       	cpi	r24, 0x08	; 8
    1cea:	08 f0       	brcs	.+2      	; 0x1cee <GPIO_readPin+0x1c>
    1cec:	84 c0       	rjmp	.+264    	; 0x1df6 <GPIO_readPin+0x124>
    1cee:	8a 81       	ldd	r24, Y+2	; 0x02
    1cf0:	84 30       	cpi	r24, 0x04	; 4
    1cf2:	08 f0       	brcs	.+2      	; 0x1cf6 <GPIO_readPin+0x24>
    1cf4:	80 c0       	rjmp	.+256    	; 0x1df6 <GPIO_readPin+0x124>
		/* Do Nothing */
	}
	else
	{
		/* Read the pin value as required */
		switch(port_num)
    1cf6:	8a 81       	ldd	r24, Y+2	; 0x02
    1cf8:	28 2f       	mov	r18, r24
    1cfa:	30 e0       	ldi	r19, 0x00	; 0
    1cfc:	3d 83       	std	Y+5, r19	; 0x05
    1cfe:	2c 83       	std	Y+4, r18	; 0x04
    1d00:	4c 81       	ldd	r20, Y+4	; 0x04
    1d02:	5d 81       	ldd	r21, Y+5	; 0x05
    1d04:	41 30       	cpi	r20, 0x01	; 1
    1d06:	51 05       	cpc	r21, r1
    1d08:	79 f1       	breq	.+94     	; 0x1d68 <GPIO_readPin+0x96>
    1d0a:	8c 81       	ldd	r24, Y+4	; 0x04
    1d0c:	9d 81       	ldd	r25, Y+5	; 0x05
    1d0e:	82 30       	cpi	r24, 0x02	; 2
    1d10:	91 05       	cpc	r25, r1
    1d12:	34 f4       	brge	.+12     	; 0x1d20 <GPIO_readPin+0x4e>
    1d14:	2c 81       	ldd	r18, Y+4	; 0x04
    1d16:	3d 81       	ldd	r19, Y+5	; 0x05
    1d18:	21 15       	cp	r18, r1
    1d1a:	31 05       	cpc	r19, r1
    1d1c:	69 f0       	breq	.+26     	; 0x1d38 <GPIO_readPin+0x66>
    1d1e:	6b c0       	rjmp	.+214    	; 0x1df6 <GPIO_readPin+0x124>
    1d20:	4c 81       	ldd	r20, Y+4	; 0x04
    1d22:	5d 81       	ldd	r21, Y+5	; 0x05
    1d24:	42 30       	cpi	r20, 0x02	; 2
    1d26:	51 05       	cpc	r21, r1
    1d28:	b9 f1       	breq	.+110    	; 0x1d98 <GPIO_readPin+0xc6>
    1d2a:	8c 81       	ldd	r24, Y+4	; 0x04
    1d2c:	9d 81       	ldd	r25, Y+5	; 0x05
    1d2e:	83 30       	cpi	r24, 0x03	; 3
    1d30:	91 05       	cpc	r25, r1
    1d32:	09 f4       	brne	.+2      	; 0x1d36 <GPIO_readPin+0x64>
    1d34:	49 c0       	rjmp	.+146    	; 0x1dc8 <GPIO_readPin+0xf6>
    1d36:	5f c0       	rjmp	.+190    	; 0x1df6 <GPIO_readPin+0x124>
		{
		case PORTA_ID:
			if(BIT_IS_SET(PINA,pin_num))
    1d38:	e9 e3       	ldi	r30, 0x39	; 57
    1d3a:	f0 e0       	ldi	r31, 0x00	; 0
    1d3c:	80 81       	ld	r24, Z
    1d3e:	28 2f       	mov	r18, r24
    1d40:	30 e0       	ldi	r19, 0x00	; 0
    1d42:	8b 81       	ldd	r24, Y+3	; 0x03
    1d44:	88 2f       	mov	r24, r24
    1d46:	90 e0       	ldi	r25, 0x00	; 0
    1d48:	a9 01       	movw	r20, r18
    1d4a:	02 c0       	rjmp	.+4      	; 0x1d50 <GPIO_readPin+0x7e>
    1d4c:	55 95       	asr	r21
    1d4e:	47 95       	ror	r20
    1d50:	8a 95       	dec	r24
    1d52:	e2 f7       	brpl	.-8      	; 0x1d4c <GPIO_readPin+0x7a>
    1d54:	ca 01       	movw	r24, r20
    1d56:	81 70       	andi	r24, 0x01	; 1
    1d58:	90 70       	andi	r25, 0x00	; 0
    1d5a:	88 23       	and	r24, r24
    1d5c:	19 f0       	breq	.+6      	; 0x1d64 <GPIO_readPin+0x92>
			{
				pin_value = LOGIC_HIGH;
    1d5e:	81 e0       	ldi	r24, 0x01	; 1
    1d60:	89 83       	std	Y+1, r24	; 0x01
    1d62:	49 c0       	rjmp	.+146    	; 0x1df6 <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    1d64:	19 82       	std	Y+1, r1	; 0x01
    1d66:	47 c0       	rjmp	.+142    	; 0x1df6 <GPIO_readPin+0x124>
			}
			break;
		case PORTB_ID:
			if(BIT_IS_SET(PINB,pin_num))
    1d68:	e6 e3       	ldi	r30, 0x36	; 54
    1d6a:	f0 e0       	ldi	r31, 0x00	; 0
    1d6c:	80 81       	ld	r24, Z
    1d6e:	28 2f       	mov	r18, r24
    1d70:	30 e0       	ldi	r19, 0x00	; 0
    1d72:	8b 81       	ldd	r24, Y+3	; 0x03
    1d74:	88 2f       	mov	r24, r24
    1d76:	90 e0       	ldi	r25, 0x00	; 0
    1d78:	a9 01       	movw	r20, r18
    1d7a:	02 c0       	rjmp	.+4      	; 0x1d80 <GPIO_readPin+0xae>
    1d7c:	55 95       	asr	r21
    1d7e:	47 95       	ror	r20
    1d80:	8a 95       	dec	r24
    1d82:	e2 f7       	brpl	.-8      	; 0x1d7c <GPIO_readPin+0xaa>
    1d84:	ca 01       	movw	r24, r20
    1d86:	81 70       	andi	r24, 0x01	; 1
    1d88:	90 70       	andi	r25, 0x00	; 0
    1d8a:	88 23       	and	r24, r24
    1d8c:	19 f0       	breq	.+6      	; 0x1d94 <GPIO_readPin+0xc2>
			{
				pin_value = LOGIC_HIGH;
    1d8e:	81 e0       	ldi	r24, 0x01	; 1
    1d90:	89 83       	std	Y+1, r24	; 0x01
    1d92:	31 c0       	rjmp	.+98     	; 0x1df6 <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    1d94:	19 82       	std	Y+1, r1	; 0x01
    1d96:	2f c0       	rjmp	.+94     	; 0x1df6 <GPIO_readPin+0x124>
			}
			break;
		case PORTC_ID:
			if(BIT_IS_SET(PINC,pin_num))
    1d98:	e3 e3       	ldi	r30, 0x33	; 51
    1d9a:	f0 e0       	ldi	r31, 0x00	; 0
    1d9c:	80 81       	ld	r24, Z
    1d9e:	28 2f       	mov	r18, r24
    1da0:	30 e0       	ldi	r19, 0x00	; 0
    1da2:	8b 81       	ldd	r24, Y+3	; 0x03
    1da4:	88 2f       	mov	r24, r24
    1da6:	90 e0       	ldi	r25, 0x00	; 0
    1da8:	a9 01       	movw	r20, r18
    1daa:	02 c0       	rjmp	.+4      	; 0x1db0 <GPIO_readPin+0xde>
    1dac:	55 95       	asr	r21
    1dae:	47 95       	ror	r20
    1db0:	8a 95       	dec	r24
    1db2:	e2 f7       	brpl	.-8      	; 0x1dac <GPIO_readPin+0xda>
    1db4:	ca 01       	movw	r24, r20
    1db6:	81 70       	andi	r24, 0x01	; 1
    1db8:	90 70       	andi	r25, 0x00	; 0
    1dba:	88 23       	and	r24, r24
    1dbc:	19 f0       	breq	.+6      	; 0x1dc4 <GPIO_readPin+0xf2>
			{
				pin_value = LOGIC_HIGH;
    1dbe:	81 e0       	ldi	r24, 0x01	; 1
    1dc0:	89 83       	std	Y+1, r24	; 0x01
    1dc2:	19 c0       	rjmp	.+50     	; 0x1df6 <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    1dc4:	19 82       	std	Y+1, r1	; 0x01
    1dc6:	17 c0       	rjmp	.+46     	; 0x1df6 <GPIO_readPin+0x124>
			}
			break;
		case PORTD_ID:
			if(BIT_IS_SET(PIND,pin_num))
    1dc8:	e0 e3       	ldi	r30, 0x30	; 48
    1dca:	f0 e0       	ldi	r31, 0x00	; 0
    1dcc:	80 81       	ld	r24, Z
    1dce:	28 2f       	mov	r18, r24
    1dd0:	30 e0       	ldi	r19, 0x00	; 0
    1dd2:	8b 81       	ldd	r24, Y+3	; 0x03
    1dd4:	88 2f       	mov	r24, r24
    1dd6:	90 e0       	ldi	r25, 0x00	; 0
    1dd8:	a9 01       	movw	r20, r18
    1dda:	02 c0       	rjmp	.+4      	; 0x1de0 <GPIO_readPin+0x10e>
    1ddc:	55 95       	asr	r21
    1dde:	47 95       	ror	r20
    1de0:	8a 95       	dec	r24
    1de2:	e2 f7       	brpl	.-8      	; 0x1ddc <GPIO_readPin+0x10a>
    1de4:	ca 01       	movw	r24, r20
    1de6:	81 70       	andi	r24, 0x01	; 1
    1de8:	90 70       	andi	r25, 0x00	; 0
    1dea:	88 23       	and	r24, r24
    1dec:	19 f0       	breq	.+6      	; 0x1df4 <GPIO_readPin+0x122>
			{
				pin_value = LOGIC_HIGH;
    1dee:	81 e0       	ldi	r24, 0x01	; 1
    1df0:	89 83       	std	Y+1, r24	; 0x01
    1df2:	01 c0       	rjmp	.+2      	; 0x1df6 <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    1df4:	19 82       	std	Y+1, r1	; 0x01
			}
			break;
		}
	}

	return pin_value;
    1df6:	89 81       	ldd	r24, Y+1	; 0x01
}
    1df8:	0f 90       	pop	r0
    1dfa:	0f 90       	pop	r0
    1dfc:	0f 90       	pop	r0
    1dfe:	0f 90       	pop	r0
    1e00:	0f 90       	pop	r0
    1e02:	cf 91       	pop	r28
    1e04:	df 91       	pop	r29
    1e06:	08 95       	ret

00001e08 <GPIO_setupPortDirection>:
 * If the direction value is PORT_INPUT all pins in this port should be input pins.
 * If the direction value is PORT_OUTPUT all pins in this port should be output pins.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_setupPortDirection(uint8 port_num, GPIO_PortDirectionType direction)
{
    1e08:	df 93       	push	r29
    1e0a:	cf 93       	push	r28
    1e0c:	00 d0       	rcall	.+0      	; 0x1e0e <GPIO_setupPortDirection+0x6>
    1e0e:	00 d0       	rcall	.+0      	; 0x1e10 <GPIO_setupPortDirection+0x8>
    1e10:	cd b7       	in	r28, 0x3d	; 61
    1e12:	de b7       	in	r29, 0x3e	; 62
    1e14:	89 83       	std	Y+1, r24	; 0x01
    1e16:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
    1e18:	89 81       	ldd	r24, Y+1	; 0x01
    1e1a:	84 30       	cpi	r24, 0x04	; 4
    1e1c:	90 f5       	brcc	.+100    	; 0x1e82 <GPIO_setupPortDirection+0x7a>
		/* Do Nothing */
	}
	else
	{
		/* Setup the port direction as required */
		switch(port_num)
    1e1e:	89 81       	ldd	r24, Y+1	; 0x01
    1e20:	28 2f       	mov	r18, r24
    1e22:	30 e0       	ldi	r19, 0x00	; 0
    1e24:	3c 83       	std	Y+4, r19	; 0x04
    1e26:	2b 83       	std	Y+3, r18	; 0x03
    1e28:	8b 81       	ldd	r24, Y+3	; 0x03
    1e2a:	9c 81       	ldd	r25, Y+4	; 0x04
    1e2c:	81 30       	cpi	r24, 0x01	; 1
    1e2e:	91 05       	cpc	r25, r1
    1e30:	d1 f0       	breq	.+52     	; 0x1e66 <GPIO_setupPortDirection+0x5e>
    1e32:	2b 81       	ldd	r18, Y+3	; 0x03
    1e34:	3c 81       	ldd	r19, Y+4	; 0x04
    1e36:	22 30       	cpi	r18, 0x02	; 2
    1e38:	31 05       	cpc	r19, r1
    1e3a:	2c f4       	brge	.+10     	; 0x1e46 <GPIO_setupPortDirection+0x3e>
    1e3c:	8b 81       	ldd	r24, Y+3	; 0x03
    1e3e:	9c 81       	ldd	r25, Y+4	; 0x04
    1e40:	00 97       	sbiw	r24, 0x00	; 0
    1e42:	61 f0       	breq	.+24     	; 0x1e5c <GPIO_setupPortDirection+0x54>
    1e44:	1e c0       	rjmp	.+60     	; 0x1e82 <GPIO_setupPortDirection+0x7a>
    1e46:	2b 81       	ldd	r18, Y+3	; 0x03
    1e48:	3c 81       	ldd	r19, Y+4	; 0x04
    1e4a:	22 30       	cpi	r18, 0x02	; 2
    1e4c:	31 05       	cpc	r19, r1
    1e4e:	81 f0       	breq	.+32     	; 0x1e70 <GPIO_setupPortDirection+0x68>
    1e50:	8b 81       	ldd	r24, Y+3	; 0x03
    1e52:	9c 81       	ldd	r25, Y+4	; 0x04
    1e54:	83 30       	cpi	r24, 0x03	; 3
    1e56:	91 05       	cpc	r25, r1
    1e58:	81 f0       	breq	.+32     	; 0x1e7a <GPIO_setupPortDirection+0x72>
    1e5a:	13 c0       	rjmp	.+38     	; 0x1e82 <GPIO_setupPortDirection+0x7a>
		{
		case PORTA_ID:
			DDRA = direction;
    1e5c:	ea e3       	ldi	r30, 0x3A	; 58
    1e5e:	f0 e0       	ldi	r31, 0x00	; 0
    1e60:	8a 81       	ldd	r24, Y+2	; 0x02
    1e62:	80 83       	st	Z, r24
    1e64:	0e c0       	rjmp	.+28     	; 0x1e82 <GPIO_setupPortDirection+0x7a>
			break;
		case PORTB_ID:
			DDRB = direction;
    1e66:	e7 e3       	ldi	r30, 0x37	; 55
    1e68:	f0 e0       	ldi	r31, 0x00	; 0
    1e6a:	8a 81       	ldd	r24, Y+2	; 0x02
    1e6c:	80 83       	st	Z, r24
    1e6e:	09 c0       	rjmp	.+18     	; 0x1e82 <GPIO_setupPortDirection+0x7a>
			break;
		case PORTC_ID:
			DDRC = direction;
    1e70:	e4 e3       	ldi	r30, 0x34	; 52
    1e72:	f0 e0       	ldi	r31, 0x00	; 0
    1e74:	8a 81       	ldd	r24, Y+2	; 0x02
    1e76:	80 83       	st	Z, r24
    1e78:	04 c0       	rjmp	.+8      	; 0x1e82 <GPIO_setupPortDirection+0x7a>
			break;
		case PORTD_ID:
			DDRD = direction;
    1e7a:	e1 e3       	ldi	r30, 0x31	; 49
    1e7c:	f0 e0       	ldi	r31, 0x00	; 0
    1e7e:	8a 81       	ldd	r24, Y+2	; 0x02
    1e80:	80 83       	st	Z, r24
			break;
		}
	}
}
    1e82:	0f 90       	pop	r0
    1e84:	0f 90       	pop	r0
    1e86:	0f 90       	pop	r0
    1e88:	0f 90       	pop	r0
    1e8a:	cf 91       	pop	r28
    1e8c:	df 91       	pop	r29
    1e8e:	08 95       	ret

00001e90 <GPIO_writePort>:
 * If any pin in the port is output pin the value will be written.
 * If any pin in the port is input pin this will activate/deactivate the internal pull-up resistor.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_writePort(uint8 port_num, uint8 value)
{
    1e90:	df 93       	push	r29
    1e92:	cf 93       	push	r28
    1e94:	00 d0       	rcall	.+0      	; 0x1e96 <GPIO_writePort+0x6>
    1e96:	00 d0       	rcall	.+0      	; 0x1e98 <GPIO_writePort+0x8>
    1e98:	cd b7       	in	r28, 0x3d	; 61
    1e9a:	de b7       	in	r29, 0x3e	; 62
    1e9c:	89 83       	std	Y+1, r24	; 0x01
    1e9e:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
    1ea0:	89 81       	ldd	r24, Y+1	; 0x01
    1ea2:	84 30       	cpi	r24, 0x04	; 4
    1ea4:	90 f5       	brcc	.+100    	; 0x1f0a <GPIO_writePort+0x7a>
		/* Do Nothing */
	}
	else
	{
		/* Write the port value as required */
		switch(port_num)
    1ea6:	89 81       	ldd	r24, Y+1	; 0x01
    1ea8:	28 2f       	mov	r18, r24
    1eaa:	30 e0       	ldi	r19, 0x00	; 0
    1eac:	3c 83       	std	Y+4, r19	; 0x04
    1eae:	2b 83       	std	Y+3, r18	; 0x03
    1eb0:	8b 81       	ldd	r24, Y+3	; 0x03
    1eb2:	9c 81       	ldd	r25, Y+4	; 0x04
    1eb4:	81 30       	cpi	r24, 0x01	; 1
    1eb6:	91 05       	cpc	r25, r1
    1eb8:	d1 f0       	breq	.+52     	; 0x1eee <GPIO_writePort+0x5e>
    1eba:	2b 81       	ldd	r18, Y+3	; 0x03
    1ebc:	3c 81       	ldd	r19, Y+4	; 0x04
    1ebe:	22 30       	cpi	r18, 0x02	; 2
    1ec0:	31 05       	cpc	r19, r1
    1ec2:	2c f4       	brge	.+10     	; 0x1ece <GPIO_writePort+0x3e>
    1ec4:	8b 81       	ldd	r24, Y+3	; 0x03
    1ec6:	9c 81       	ldd	r25, Y+4	; 0x04
    1ec8:	00 97       	sbiw	r24, 0x00	; 0
    1eca:	61 f0       	breq	.+24     	; 0x1ee4 <GPIO_writePort+0x54>
    1ecc:	1e c0       	rjmp	.+60     	; 0x1f0a <GPIO_writePort+0x7a>
    1ece:	2b 81       	ldd	r18, Y+3	; 0x03
    1ed0:	3c 81       	ldd	r19, Y+4	; 0x04
    1ed2:	22 30       	cpi	r18, 0x02	; 2
    1ed4:	31 05       	cpc	r19, r1
    1ed6:	81 f0       	breq	.+32     	; 0x1ef8 <GPIO_writePort+0x68>
    1ed8:	8b 81       	ldd	r24, Y+3	; 0x03
    1eda:	9c 81       	ldd	r25, Y+4	; 0x04
    1edc:	83 30       	cpi	r24, 0x03	; 3
    1ede:	91 05       	cpc	r25, r1
    1ee0:	81 f0       	breq	.+32     	; 0x1f02 <GPIO_writePort+0x72>
    1ee2:	13 c0       	rjmp	.+38     	; 0x1f0a <GPIO_writePort+0x7a>
		{
		case PORTA_ID:
			PORTA = value;
    1ee4:	eb e3       	ldi	r30, 0x3B	; 59
    1ee6:	f0 e0       	ldi	r31, 0x00	; 0
    1ee8:	8a 81       	ldd	r24, Y+2	; 0x02
    1eea:	80 83       	st	Z, r24
    1eec:	0e c0       	rjmp	.+28     	; 0x1f0a <GPIO_writePort+0x7a>
			break;
		case PORTB_ID:
			PORTB = value;
    1eee:	e8 e3       	ldi	r30, 0x38	; 56
    1ef0:	f0 e0       	ldi	r31, 0x00	; 0
    1ef2:	8a 81       	ldd	r24, Y+2	; 0x02
    1ef4:	80 83       	st	Z, r24
    1ef6:	09 c0       	rjmp	.+18     	; 0x1f0a <GPIO_writePort+0x7a>
			break;
		case PORTC_ID:
			PORTC = value;
    1ef8:	e5 e3       	ldi	r30, 0x35	; 53
    1efa:	f0 e0       	ldi	r31, 0x00	; 0
    1efc:	8a 81       	ldd	r24, Y+2	; 0x02
    1efe:	80 83       	st	Z, r24
    1f00:	04 c0       	rjmp	.+8      	; 0x1f0a <GPIO_writePort+0x7a>
			break;
		case PORTD_ID:
			PORTD = value;
    1f02:	e2 e3       	ldi	r30, 0x32	; 50
    1f04:	f0 e0       	ldi	r31, 0x00	; 0
    1f06:	8a 81       	ldd	r24, Y+2	; 0x02
    1f08:	80 83       	st	Z, r24
			break;
		}
	}
}
    1f0a:	0f 90       	pop	r0
    1f0c:	0f 90       	pop	r0
    1f0e:	0f 90       	pop	r0
    1f10:	0f 90       	pop	r0
    1f12:	cf 91       	pop	r28
    1f14:	df 91       	pop	r29
    1f16:	08 95       	ret

00001f18 <GPIO_readPort>:
 * Description :
 * Read and return the value of the required port.
 * If the input port number is not correct, The function will return ZERO value.
 */
uint8 GPIO_readPort(uint8 port_num)
{
    1f18:	df 93       	push	r29
    1f1a:	cf 93       	push	r28
    1f1c:	00 d0       	rcall	.+0      	; 0x1f1e <GPIO_readPort+0x6>
    1f1e:	00 d0       	rcall	.+0      	; 0x1f20 <GPIO_readPort+0x8>
    1f20:	cd b7       	in	r28, 0x3d	; 61
    1f22:	de b7       	in	r29, 0x3e	; 62
    1f24:	8a 83       	std	Y+2, r24	; 0x02
	uint8 value = LOGIC_LOW;
    1f26:	19 82       	std	Y+1, r1	; 0x01

	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
    1f28:	8a 81       	ldd	r24, Y+2	; 0x02
    1f2a:	84 30       	cpi	r24, 0x04	; 4
    1f2c:	90 f5       	brcc	.+100    	; 0x1f92 <GPIO_readPort+0x7a>
		/* Do Nothing */
	}
	else
	{
		/* Read the port value as required */
		switch(port_num)
    1f2e:	8a 81       	ldd	r24, Y+2	; 0x02
    1f30:	28 2f       	mov	r18, r24
    1f32:	30 e0       	ldi	r19, 0x00	; 0
    1f34:	3c 83       	std	Y+4, r19	; 0x04
    1f36:	2b 83       	std	Y+3, r18	; 0x03
    1f38:	8b 81       	ldd	r24, Y+3	; 0x03
    1f3a:	9c 81       	ldd	r25, Y+4	; 0x04
    1f3c:	81 30       	cpi	r24, 0x01	; 1
    1f3e:	91 05       	cpc	r25, r1
    1f40:	d1 f0       	breq	.+52     	; 0x1f76 <GPIO_readPort+0x5e>
    1f42:	2b 81       	ldd	r18, Y+3	; 0x03
    1f44:	3c 81       	ldd	r19, Y+4	; 0x04
    1f46:	22 30       	cpi	r18, 0x02	; 2
    1f48:	31 05       	cpc	r19, r1
    1f4a:	2c f4       	brge	.+10     	; 0x1f56 <GPIO_readPort+0x3e>
    1f4c:	8b 81       	ldd	r24, Y+3	; 0x03
    1f4e:	9c 81       	ldd	r25, Y+4	; 0x04
    1f50:	00 97       	sbiw	r24, 0x00	; 0
    1f52:	61 f0       	breq	.+24     	; 0x1f6c <GPIO_readPort+0x54>
    1f54:	1e c0       	rjmp	.+60     	; 0x1f92 <GPIO_readPort+0x7a>
    1f56:	2b 81       	ldd	r18, Y+3	; 0x03
    1f58:	3c 81       	ldd	r19, Y+4	; 0x04
    1f5a:	22 30       	cpi	r18, 0x02	; 2
    1f5c:	31 05       	cpc	r19, r1
    1f5e:	81 f0       	breq	.+32     	; 0x1f80 <GPIO_readPort+0x68>
    1f60:	8b 81       	ldd	r24, Y+3	; 0x03
    1f62:	9c 81       	ldd	r25, Y+4	; 0x04
    1f64:	83 30       	cpi	r24, 0x03	; 3
    1f66:	91 05       	cpc	r25, r1
    1f68:	81 f0       	breq	.+32     	; 0x1f8a <GPIO_readPort+0x72>
    1f6a:	13 c0       	rjmp	.+38     	; 0x1f92 <GPIO_readPort+0x7a>
		{
		case PORTA_ID:
			value = PINA;
    1f6c:	e9 e3       	ldi	r30, 0x39	; 57
    1f6e:	f0 e0       	ldi	r31, 0x00	; 0
    1f70:	80 81       	ld	r24, Z
    1f72:	89 83       	std	Y+1, r24	; 0x01
    1f74:	0e c0       	rjmp	.+28     	; 0x1f92 <GPIO_readPort+0x7a>
			break;
		case PORTB_ID:
			value = PINB;
    1f76:	e6 e3       	ldi	r30, 0x36	; 54
    1f78:	f0 e0       	ldi	r31, 0x00	; 0
    1f7a:	80 81       	ld	r24, Z
    1f7c:	89 83       	std	Y+1, r24	; 0x01
    1f7e:	09 c0       	rjmp	.+18     	; 0x1f92 <GPIO_readPort+0x7a>
			break;
		case PORTC_ID:
			value = PINC;
    1f80:	e3 e3       	ldi	r30, 0x33	; 51
    1f82:	f0 e0       	ldi	r31, 0x00	; 0
    1f84:	80 81       	ld	r24, Z
    1f86:	89 83       	std	Y+1, r24	; 0x01
    1f88:	04 c0       	rjmp	.+8      	; 0x1f92 <GPIO_readPort+0x7a>
			break;
		case PORTD_ID:
			value = PIND;
    1f8a:	e0 e3       	ldi	r30, 0x30	; 48
    1f8c:	f0 e0       	ldi	r31, 0x00	; 0
    1f8e:	80 81       	ld	r24, Z
    1f90:	89 83       	std	Y+1, r24	; 0x01
			break;
		}
	}

	return value;
    1f92:	89 81       	ldd	r24, Y+1	; 0x01
}
    1f94:	0f 90       	pop	r0
    1f96:	0f 90       	pop	r0
    1f98:	0f 90       	pop	r0
    1f9a:	0f 90       	pop	r0
    1f9c:	cf 91       	pop	r28
    1f9e:	df 91       	pop	r29
    1fa0:	08 95       	ret

00001fa2 <PWM_Timer0_Start>:
 *  Created on: Feb 22, 2024
 *      Author: dell
 */
#include "motor_mine.h"
							/*****TIMER 0 PWM mode*****/
void PWM_Timer0_Start(uint8 duty_cycle){
    1fa2:	df 93       	push	r29
    1fa4:	cf 93       	push	r28
    1fa6:	0f 92       	push	r0
    1fa8:	cd b7       	in	r28, 0x3d	; 61
    1faa:	de b7       	in	r29, 0x3e	; 62
    1fac:	89 83       	std	Y+1, r24	; 0x01
		TCNT0 = 0; /* Set Timer Initial Value to 0*/
    1fae:	e2 e5       	ldi	r30, 0x52	; 82
    1fb0:	f0 e0       	ldi	r31, 0x00	; 0
    1fb2:	10 82       	st	Z, r1
		/* F CPU = 1 MHZ
		 * F PWM = 500 HZ
		 * N = 8*/
		OCR0  = ((255)*(duty_cycle/(100))); /*Set Compare value*/
    1fb4:	ec e5       	ldi	r30, 0x5C	; 92
    1fb6:	f0 e0       	ldi	r31, 0x00	; 0
    1fb8:	89 81       	ldd	r24, Y+1	; 0x01
    1fba:	94 e6       	ldi	r25, 0x64	; 100
    1fbc:	69 2f       	mov	r22, r25
    1fbe:	0e 94 37 12 	call	0x246e	; 0x246e <__udivmodqi4>
    1fc2:	48 2f       	mov	r20, r24
    1fc4:	50 e0       	ldi	r21, 0x00	; 0
    1fc6:	ca 01       	movw	r24, r20
    1fc8:	9c 01       	movw	r18, r24
    1fca:	22 0f       	add	r18, r18
    1fcc:	33 1f       	adc	r19, r19
    1fce:	c9 01       	movw	r24, r18
    1fd0:	96 95       	lsr	r25
    1fd2:	98 2f       	mov	r25, r24
    1fd4:	88 27       	eor	r24, r24
    1fd6:	97 95       	ror	r25
    1fd8:	87 95       	ror	r24
    1fda:	82 1b       	sub	r24, r18
    1fdc:	93 0b       	sbc	r25, r19
    1fde:	84 0f       	add	r24, r20
    1fe0:	95 1f       	adc	r25, r21
    1fe2:	80 83       	st	Z, r24
		DDRB  = DDRB | (1<<PB3);/*EN1  output pin for PWM*/
    1fe4:	a7 e3       	ldi	r26, 0x37	; 55
    1fe6:	b0 e0       	ldi	r27, 0x00	; 0
    1fe8:	e7 e3       	ldi	r30, 0x37	; 55
    1fea:	f0 e0       	ldi	r31, 0x00	; 0
    1fec:	80 81       	ld	r24, Z
    1fee:	88 60       	ori	r24, 0x08	; 8
    1ff0:	8c 93       	st	X, r24
		 * 1. Fast PWM mode FOC0=0
		 * 2. Fast PWM Mode WGM01=1 & WGM00=1
		 * 3. Clear OC0 when match occurs (non inverted mode) COM00=0 & COM01=1
		 * 4. clock = F_CPU/8 CS00=0 CS01=1 CS02=0
		 */
		TCCR0 = (1<<WGM00) | (1<<WGM01) | (1<<COM01) | (1<<CS01);
    1ff2:	e3 e5       	ldi	r30, 0x53	; 83
    1ff4:	f0 e0       	ldi	r31, 0x00	; 0
    1ff6:	8a e6       	ldi	r24, 0x6A	; 106
    1ff8:	80 83       	st	Z, r24
}
    1ffa:	0f 90       	pop	r0
    1ffc:	cf 91       	pop	r28
    1ffe:	df 91       	pop	r29
    2000:	08 95       	ret

00002002 <DcMotor_Init>:

void DcMotor_Init(void){
    2002:	df 93       	push	r29
    2004:	cf 93       	push	r28
    2006:	cd b7       	in	r28, 0x3d	; 61
    2008:	de b7       	in	r29, 0x3e	; 62
	/*set up pin directions*/
	GPIO_setupPinDirection(PORTB_ID,PIN3_ID,PIN_OUTPUT);/*EN1*/
    200a:	81 e0       	ldi	r24, 0x01	; 1
    200c:	63 e0       	ldi	r22, 0x03	; 3
    200e:	41 e0       	ldi	r20, 0x01	; 1
    2010:	0e 94 93 0c 	call	0x1926	; 0x1926 <GPIO_setupPinDirection>
	GPIO_setupPinDirection(PORTA_ID,PIN6_ID,PIN_OUTPUT);/*IN1*/
    2014:	80 e0       	ldi	r24, 0x00	; 0
    2016:	66 e0       	ldi	r22, 0x06	; 6
    2018:	41 e0       	ldi	r20, 0x01	; 1
    201a:	0e 94 93 0c 	call	0x1926	; 0x1926 <GPIO_setupPinDirection>
	GPIO_setupPinDirection(PORTA_ID,PIN5_ID,PIN_OUTPUT);/*IN2*/
    201e:	80 e0       	ldi	r24, 0x00	; 0
    2020:	65 e0       	ldi	r22, 0x05	; 5
    2022:	41 e0       	ldi	r20, 0x01	; 1
    2024:	0e 94 93 0c 	call	0x1926	; 0x1926 <GPIO_setupPinDirection>


	//intiial state
	timer1_is_init=0;
    2028:	10 92 77 00 	sts	0x0077, r1
	locking_door=0;
    202c:	10 92 78 00 	sts	0x0078, r1
}
    2030:	cf 91       	pop	r28
    2032:	df 91       	pop	r29
    2034:	08 95       	ret

00002036 <DcMotor_Rotate>:

void DcMotor_Rotate(DcMotor_State state,uint8 speed){
    2036:	df 93       	push	r29
    2038:	cf 93       	push	r28
    203a:	00 d0       	rcall	.+0      	; 0x203c <DcMotor_Rotate+0x6>
    203c:	cd b7       	in	r28, 0x3d	; 61
    203e:	de b7       	in	r29, 0x3e	; 62
    2040:	89 83       	std	Y+1, r24	; 0x01
    2042:	6a 83       	std	Y+2, r22	; 0x02
	PWM_Timer0_Start(speed);
    2044:	8a 81       	ldd	r24, Y+2	; 0x02
    2046:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <PWM_Timer0_Start>
	    if (state == MOTOR_OFF) {
    204a:	89 81       	ldd	r24, Y+1	; 0x01
    204c:	88 23       	and	r24, r24
    204e:	81 f4       	brne	.+32     	; 0x2070 <DcMotor_Rotate+0x3a>
	        /* Stop the motor */
	    	GPIO_writePin(PORTB_ID,PIN3_ID,LOGIC_LOW);/*EN1*/
    2050:	81 e0       	ldi	r24, 0x01	; 1
    2052:	63 e0       	ldi	r22, 0x03	; 3
    2054:	40 e0       	ldi	r20, 0x00	; 0
    2056:	0e 94 7e 0d 	call	0x1afc	; 0x1afc <GPIO_writePin>
	        GPIO_writePin(PORTA_ID, PIN6_ID, 0); /* IN1 */
    205a:	80 e0       	ldi	r24, 0x00	; 0
    205c:	66 e0       	ldi	r22, 0x06	; 6
    205e:	40 e0       	ldi	r20, 0x00	; 0
    2060:	0e 94 7e 0d 	call	0x1afc	; 0x1afc <GPIO_writePin>
	        GPIO_writePin(PORTA_ID, PIN5_ID, 0); /* IN2 */
    2064:	80 e0       	ldi	r24, 0x00	; 0
    2066:	65 e0       	ldi	r22, 0x05	; 5
    2068:	40 e0       	ldi	r20, 0x00	; 0
    206a:	0e 94 7e 0d 	call	0x1afc	; 0x1afc <GPIO_writePin>
    206e:	1b c0       	rjmp	.+54     	; 0x20a6 <DcMotor_Rotate+0x70>
	    } else if (state == MOTOR_CW) {
    2070:	89 81       	ldd	r24, Y+1	; 0x01
    2072:	81 30       	cpi	r24, 0x01	; 1
    2074:	59 f4       	brne	.+22     	; 0x208c <DcMotor_Rotate+0x56>
	        /* Rotate the motor clockwise */
	        GPIO_writePin(PORTA_ID, PIN6_ID, 0); /* IN1 */
    2076:	80 e0       	ldi	r24, 0x00	; 0
    2078:	66 e0       	ldi	r22, 0x06	; 6
    207a:	40 e0       	ldi	r20, 0x00	; 0
    207c:	0e 94 7e 0d 	call	0x1afc	; 0x1afc <GPIO_writePin>
	        GPIO_writePin(PORTA_ID, PIN5_ID, 1); /* IN2 */
    2080:	80 e0       	ldi	r24, 0x00	; 0
    2082:	65 e0       	ldi	r22, 0x05	; 5
    2084:	41 e0       	ldi	r20, 0x01	; 1
    2086:	0e 94 7e 0d 	call	0x1afc	; 0x1afc <GPIO_writePin>
    208a:	0d c0       	rjmp	.+26     	; 0x20a6 <DcMotor_Rotate+0x70>
	    } else if (state == MOTOR_A_CW) {
    208c:	89 81       	ldd	r24, Y+1	; 0x01
    208e:	82 30       	cpi	r24, 0x02	; 2
    2090:	51 f4       	brne	.+20     	; 0x20a6 <DcMotor_Rotate+0x70>
	        /* Rotate the motor anti-clockwise */
	        GPIO_writePin(PORTA_ID, PIN6_ID, 1); /* IN1 */
    2092:	80 e0       	ldi	r24, 0x00	; 0
    2094:	66 e0       	ldi	r22, 0x06	; 6
    2096:	41 e0       	ldi	r20, 0x01	; 1
    2098:	0e 94 7e 0d 	call	0x1afc	; 0x1afc <GPIO_writePin>
	        GPIO_writePin(PORTA_ID, PIN5_ID, 0); /* IN2 */
    209c:	80 e0       	ldi	r24, 0x00	; 0
    209e:	65 e0       	ldi	r22, 0x05	; 5
    20a0:	40 e0       	ldi	r20, 0x00	; 0
    20a2:	0e 94 7e 0d 	call	0x1afc	; 0x1afc <GPIO_writePin>
	    }
}
    20a6:	0f 90       	pop	r0
    20a8:	0f 90       	pop	r0
    20aa:	cf 91       	pop	r28
    20ac:	df 91       	pop	r29
    20ae:	08 95       	ret

000020b0 <Start_DcMotor_TIMER1>:



/**************************************FOR MOTOR tIMER***********************************/
void Start_DcMotor_TIMER1(){
    20b0:	df 93       	push	r29
    20b2:	cf 93       	push	r28
    20b4:	cd b7       	in	r28, 0x3d	; 61
    20b6:	de b7       	in	r29, 0x3e	; 62
	/************Initialize TIMER1*******************/
		timer1config.initial_value = 0;
    20b8:	10 92 6c 00 	sts	0x006C, r1
    20bc:	10 92 6b 00 	sts	0x006B, r1
		timer1config.compare_value =7812;
    20c0:	84 e8       	ldi	r24, 0x84	; 132
    20c2:	9e e1       	ldi	r25, 0x1E	; 30
    20c4:	90 93 6e 00 	sts	0x006E, r25
    20c8:	80 93 6d 00 	sts	0x006D, r24
		timer1config.prescaler = PRESCALER__1024;
    20cc:	85 e0       	ldi	r24, 0x05	; 5
    20ce:	80 93 6f 00 	sts	0x006F, r24
		timer1config.mode = CTC_TOP_OCR1A;
    20d2:	84 e0       	ldi	r24, 0x04	; 4
    20d4:	80 93 70 00 	sts	0x0070, r24
		Timer1_init(&timer1config);
    20d8:	8b e6       	ldi	r24, 0x6B	; 107
    20da:	90 e0       	ldi	r25, 0x00	; 0
    20dc:	0e 94 63 0b 	call	0x16c6	; 0x16c6 <Timer1_init>
		timer1_is_init++;
    20e0:	80 91 77 00 	lds	r24, 0x0077
    20e4:	8f 5f       	subi	r24, 0xFF	; 255
    20e6:	80 93 77 00 	sts	0x0077, r24
		Timer1_setCallBack(&DcMotor_timer_finished);
    20ea:	8c e7       	ldi	r24, 0x7C	; 124
    20ec:	90 e1       	ldi	r25, 0x10	; 16
    20ee:	0e 94 cf 0b 	call	0x179e	; 0x179e <Timer1_setCallBack>
}
    20f2:	cf 91       	pop	r28
    20f4:	df 91       	pop	r29
    20f6:	08 95       	ret

000020f8 <DcMotor_timer_finished>:



void DcMotor_timer_finished(void){
    20f8:	df 93       	push	r29
    20fa:	cf 93       	push	r28
    20fc:	cd b7       	in	r28, 0x3d	; 61
    20fe:	de b7       	in	r29, 0x3e	; 62
    2100:	2e 97       	sbiw	r28, 0x0e	; 14
    2102:	0f b6       	in	r0, 0x3f	; 63
    2104:	f8 94       	cli
    2106:	de bf       	out	0x3e, r29	; 62
    2108:	0f be       	out	0x3f, r0	; 63
    210a:	cd bf       	out	0x3d, r28	; 61
	if(locking_door==1){//DOOR IS LOCKING
    210c:	80 91 78 00 	lds	r24, 0x0078
    2110:	81 30       	cpi	r24, 0x01	; 1
    2112:	39 f4       	brne	.+14     	; 0x2122 <DcMotor_timer_finished+0x2a>
		Timer1_deInit();
    2114:	0e 94 be 0b 	call	0x177c	; 0x177c <Timer1_deInit>
		DcMotor_Rotate(MOTOR_OFF,0);
    2118:	80 e0       	ldi	r24, 0x00	; 0
    211a:	60 e0       	ldi	r22, 0x00	; 0
    211c:	0e 94 1b 10 	call	0x2036	; 0x2036 <DcMotor_Rotate>
    2120:	7d c0       	rjmp	.+250    	; 0x221c <DcMotor_timer_finished+0x124>
	}
	else{
	DcMotor_Rotate(MOTOR_OFF,0);
    2122:	80 e0       	ldi	r24, 0x00	; 0
    2124:	60 e0       	ldi	r22, 0x00	; 0
    2126:	0e 94 1b 10 	call	0x2036	; 0x2036 <DcMotor_Rotate>
    212a:	80 e0       	ldi	r24, 0x00	; 0
    212c:	90 e8       	ldi	r25, 0x80	; 128
    212e:	ab e3       	ldi	r26, 0x3B	; 59
    2130:	b5 e4       	ldi	r27, 0x45	; 69
    2132:	8b 87       	std	Y+11, r24	; 0x0b
    2134:	9c 87       	std	Y+12, r25	; 0x0c
    2136:	ad 87       	std	Y+13, r26	; 0x0d
    2138:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    213a:	6b 85       	ldd	r22, Y+11	; 0x0b
    213c:	7c 85       	ldd	r23, Y+12	; 0x0c
    213e:	8d 85       	ldd	r24, Y+13	; 0x0d
    2140:	9e 85       	ldd	r25, Y+14	; 0x0e
    2142:	20 e0       	ldi	r18, 0x00	; 0
    2144:	30 e0       	ldi	r19, 0x00	; 0
    2146:	4a ef       	ldi	r20, 0xFA	; 250
    2148:	54 e4       	ldi	r21, 0x44	; 68
    214a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    214e:	dc 01       	movw	r26, r24
    2150:	cb 01       	movw	r24, r22
    2152:	8f 83       	std	Y+7, r24	; 0x07
    2154:	98 87       	std	Y+8, r25	; 0x08
    2156:	a9 87       	std	Y+9, r26	; 0x09
    2158:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    215a:	6f 81       	ldd	r22, Y+7	; 0x07
    215c:	78 85       	ldd	r23, Y+8	; 0x08
    215e:	89 85       	ldd	r24, Y+9	; 0x09
    2160:	9a 85       	ldd	r25, Y+10	; 0x0a
    2162:	20 e0       	ldi	r18, 0x00	; 0
    2164:	30 e0       	ldi	r19, 0x00	; 0
    2166:	40 e8       	ldi	r20, 0x80	; 128
    2168:	5f e3       	ldi	r21, 0x3F	; 63
    216a:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    216e:	88 23       	and	r24, r24
    2170:	2c f4       	brge	.+10     	; 0x217c <DcMotor_timer_finished+0x84>
		__ticks = 1;
    2172:	81 e0       	ldi	r24, 0x01	; 1
    2174:	90 e0       	ldi	r25, 0x00	; 0
    2176:	9e 83       	std	Y+6, r25	; 0x06
    2178:	8d 83       	std	Y+5, r24	; 0x05
    217a:	3f c0       	rjmp	.+126    	; 0x21fa <DcMotor_timer_finished+0x102>
	else if (__tmp > 65535)
    217c:	6f 81       	ldd	r22, Y+7	; 0x07
    217e:	78 85       	ldd	r23, Y+8	; 0x08
    2180:	89 85       	ldd	r24, Y+9	; 0x09
    2182:	9a 85       	ldd	r25, Y+10	; 0x0a
    2184:	20 e0       	ldi	r18, 0x00	; 0
    2186:	3f ef       	ldi	r19, 0xFF	; 255
    2188:	4f e7       	ldi	r20, 0x7F	; 127
    218a:	57 e4       	ldi	r21, 0x47	; 71
    218c:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2190:	18 16       	cp	r1, r24
    2192:	4c f5       	brge	.+82     	; 0x21e6 <DcMotor_timer_finished+0xee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2194:	6b 85       	ldd	r22, Y+11	; 0x0b
    2196:	7c 85       	ldd	r23, Y+12	; 0x0c
    2198:	8d 85       	ldd	r24, Y+13	; 0x0d
    219a:	9e 85       	ldd	r25, Y+14	; 0x0e
    219c:	20 e0       	ldi	r18, 0x00	; 0
    219e:	30 e0       	ldi	r19, 0x00	; 0
    21a0:	40 e2       	ldi	r20, 0x20	; 32
    21a2:	51 e4       	ldi	r21, 0x41	; 65
    21a4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    21a8:	dc 01       	movw	r26, r24
    21aa:	cb 01       	movw	r24, r22
    21ac:	bc 01       	movw	r22, r24
    21ae:	cd 01       	movw	r24, r26
    21b0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    21b4:	dc 01       	movw	r26, r24
    21b6:	cb 01       	movw	r24, r22
    21b8:	9e 83       	std	Y+6, r25	; 0x06
    21ba:	8d 83       	std	Y+5, r24	; 0x05
    21bc:	0f c0       	rjmp	.+30     	; 0x21dc <DcMotor_timer_finished+0xe4>
    21be:	88 ec       	ldi	r24, 0xC8	; 200
    21c0:	90 e0       	ldi	r25, 0x00	; 0
    21c2:	9c 83       	std	Y+4, r25	; 0x04
    21c4:	8b 83       	std	Y+3, r24	; 0x03
    21c6:	8b 81       	ldd	r24, Y+3	; 0x03
    21c8:	9c 81       	ldd	r25, Y+4	; 0x04
    21ca:	01 97       	sbiw	r24, 0x01	; 1
    21cc:	f1 f7       	brne	.-4      	; 0x21ca <DcMotor_timer_finished+0xd2>
    21ce:	9c 83       	std	Y+4, r25	; 0x04
    21d0:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    21d2:	8d 81       	ldd	r24, Y+5	; 0x05
    21d4:	9e 81       	ldd	r25, Y+6	; 0x06
    21d6:	01 97       	sbiw	r24, 0x01	; 1
    21d8:	9e 83       	std	Y+6, r25	; 0x06
    21da:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    21dc:	8d 81       	ldd	r24, Y+5	; 0x05
    21de:	9e 81       	ldd	r25, Y+6	; 0x06
    21e0:	00 97       	sbiw	r24, 0x00	; 0
    21e2:	69 f7       	brne	.-38     	; 0x21be <DcMotor_timer_finished+0xc6>
    21e4:	14 c0       	rjmp	.+40     	; 0x220e <DcMotor_timer_finished+0x116>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    21e6:	6f 81       	ldd	r22, Y+7	; 0x07
    21e8:	78 85       	ldd	r23, Y+8	; 0x08
    21ea:	89 85       	ldd	r24, Y+9	; 0x09
    21ec:	9a 85       	ldd	r25, Y+10	; 0x0a
    21ee:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    21f2:	dc 01       	movw	r26, r24
    21f4:	cb 01       	movw	r24, r22
    21f6:	9e 83       	std	Y+6, r25	; 0x06
    21f8:	8d 83       	std	Y+5, r24	; 0x05
    21fa:	8d 81       	ldd	r24, Y+5	; 0x05
    21fc:	9e 81       	ldd	r25, Y+6	; 0x06
    21fe:	9a 83       	std	Y+2, r25	; 0x02
    2200:	89 83       	std	Y+1, r24	; 0x01
    2202:	89 81       	ldd	r24, Y+1	; 0x01
    2204:	9a 81       	ldd	r25, Y+2	; 0x02
    2206:	01 97       	sbiw	r24, 0x01	; 1
    2208:	f1 f7       	brne	.-4      	; 0x2206 <DcMotor_timer_finished+0x10e>
    220a:	9a 83       	std	Y+2, r25	; 0x02
    220c:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(3000);//hold the motor f0r 3 seconds
	DcMotor_Rotate(MOTOR_A_CW,100);//door is locked
    220e:	82 e0       	ldi	r24, 0x02	; 2
    2210:	64 e6       	ldi	r22, 0x64	; 100
    2212:	0e 94 1b 10 	call	0x2036	; 0x2036 <DcMotor_Rotate>
	locking_door=1;
    2216:	81 e0       	ldi	r24, 0x01	; 1
    2218:	80 93 78 00 	sts	0x0078, r24
	}

}
    221c:	2e 96       	adiw	r28, 0x0e	; 14
    221e:	0f b6       	in	r0, 0x3f	; 63
    2220:	f8 94       	cli
    2222:	de bf       	out	0x3e, r29	; 62
    2224:	0f be       	out	0x3f, r0	; 63
    2226:	cd bf       	out	0x3d, r28	; 61
    2228:	cf 91       	pop	r28
    222a:	df 91       	pop	r29
    222c:	08 95       	ret

0000222e <UART_init>:

#include"uart_mine.h"
#include"Common_Macros.h"
#include "avr/io.h" /* To use the UART Registers */

void UART_init(const UART_ConfigType *Config_Ptr){
    222e:	df 93       	push	r29
    2230:	cf 93       	push	r28
    2232:	00 d0       	rcall	.+0      	; 0x2234 <UART_init+0x6>
    2234:	00 d0       	rcall	.+0      	; 0x2236 <UART_init+0x8>
    2236:	00 d0       	rcall	.+0      	; 0x2238 <UART_init+0xa>
    2238:	cd b7       	in	r28, 0x3d	; 61
    223a:	de b7       	in	r29, 0x3e	; 62
    223c:	9e 83       	std	Y+6, r25	; 0x06
    223e:	8d 83       	std	Y+5, r24	; 0x05

	uint16 ubrr_value = 0;/*UBRR RGISTER INTIAL VALUE*/
    2240:	1c 82       	std	Y+4, r1	; 0x04
    2242:	1b 82       	std	Y+3, r1	; 0x03
	uint16 baud_rate_value=0;
    2244:	1a 82       	std	Y+2, r1	; 0x02
    2246:	19 82       	std	Y+1, r1	; 0x01

	/* U2X = 1 for double transmission speed */
	SET_BIT(UCSRA,U2X);
    2248:	ab e2       	ldi	r26, 0x2B	; 43
    224a:	b0 e0       	ldi	r27, 0x00	; 0
    224c:	eb e2       	ldi	r30, 0x2B	; 43
    224e:	f0 e0       	ldi	r31, 0x00	; 0
    2250:	80 81       	ld	r24, Z
    2252:	82 60       	ori	r24, 0x02	; 2
    2254:	8c 93       	st	X, r24
		 * RXEN  = 1 Receiver Enable
		 * RXEN  = 1 Transmitter Enable
		 * UCSZ2 = 0 For 8-bit data mode
		 * RXB8 & TXB8 not used for 8-bit data mode
		 ***********************************************************************/
	SET_BIT(UCSRB,RXEN);
    2256:	aa e2       	ldi	r26, 0x2A	; 42
    2258:	b0 e0       	ldi	r27, 0x00	; 0
    225a:	ea e2       	ldi	r30, 0x2A	; 42
    225c:	f0 e0       	ldi	r31, 0x00	; 0
    225e:	80 81       	ld	r24, Z
    2260:	80 61       	ori	r24, 0x10	; 16
    2262:	8c 93       	st	X, r24
	SET_BIT(UCSRB,TXEN);
    2264:	aa e2       	ldi	r26, 0x2A	; 42
    2266:	b0 e0       	ldi	r27, 0x00	; 0
    2268:	ea e2       	ldi	r30, 0x2A	; 42
    226a:	f0 e0       	ldi	r31, 0x00	; 0
    226c:	80 81       	ld	r24, Z
    226e:	88 60       	ori	r24, 0x08	; 8
    2270:	8c 93       	st	X, r24
		 * UPM1:0  = 00 Disable parity bit
		 * USBS    = 0 One stop bit
		 * UCSZ1:0 = 11 For 8-bit data mode
		 * UCPOL   = 0 Used with the Synchronous operation only
		 ***********************************************************************/
	SET_BIT(UCSRC,URSEL);/*The URSEL must be one when writing the UCSRC*/
    2272:	a0 e4       	ldi	r26, 0x40	; 64
    2274:	b0 e0       	ldi	r27, 0x00	; 0
    2276:	e0 e4       	ldi	r30, 0x40	; 64
    2278:	f0 e0       	ldi	r31, 0x00	; 0
    227a:	80 81       	ld	r24, Z
    227c:	80 68       	ori	r24, 0x80	; 128
    227e:	8c 93       	st	X, r24
	CLEAR_BIT(UCSRC,UMSEL);
    2280:	a0 e4       	ldi	r26, 0x40	; 64
    2282:	b0 e0       	ldi	r27, 0x00	; 0
    2284:	e0 e4       	ldi	r30, 0x40	; 64
    2286:	f0 e0       	ldi	r31, 0x00	; 0
    2288:	80 81       	ld	r24, Z
    228a:	8f 7b       	andi	r24, 0xBF	; 191
    228c:	8c 93       	st	X, r24
/*Character size(bite mode)(bite size)*/
UCSRC=(UCSRC|0xF9)|((Config_Ptr->bit_data) &0x9F);
    228e:	a0 e4       	ldi	r26, 0x40	; 64
    2290:	b0 e0       	ldi	r27, 0x00	; 0
    2292:	e0 e4       	ldi	r30, 0x40	; 64
    2294:	f0 e0       	ldi	r31, 0x00	; 0
    2296:	80 81       	ld	r24, Z
    2298:	89 6f       	ori	r24, 0xF9	; 249
    229a:	98 2f       	mov	r25, r24
    229c:	ed 81       	ldd	r30, Y+5	; 0x05
    229e:	fe 81       	ldd	r31, Y+6	; 0x06
    22a0:	80 81       	ld	r24, Z
    22a2:	8f 79       	andi	r24, 0x9F	; 159
    22a4:	89 2b       	or	r24, r25
    22a6:	8c 93       	st	X, r24
/*parity*/
UCSRC=(UCSRC|0xCF)|((Config_Ptr->parity) &0xFC);
    22a8:	a0 e4       	ldi	r26, 0x40	; 64
    22aa:	b0 e0       	ldi	r27, 0x00	; 0
    22ac:	e0 e4       	ldi	r30, 0x40	; 64
    22ae:	f0 e0       	ldi	r31, 0x00	; 0
    22b0:	80 81       	ld	r24, Z
    22b2:	8f 6c       	ori	r24, 0xCF	; 207
    22b4:	98 2f       	mov	r25, r24
    22b6:	ed 81       	ldd	r30, Y+5	; 0x05
    22b8:	fe 81       	ldd	r31, Y+6	; 0x06
    22ba:	81 81       	ldd	r24, Z+1	; 0x01
    22bc:	8c 7f       	andi	r24, 0xFC	; 252
    22be:	89 2b       	or	r24, r25
    22c0:	8c 93       	st	X, r24
/*stop bit*/
UCSRC=(UCSRC|0xF7)|((Config_Ptr->stop_bit) &0x7F);
    22c2:	a0 e4       	ldi	r26, 0x40	; 64
    22c4:	b0 e0       	ldi	r27, 0x00	; 0
    22c6:	e0 e4       	ldi	r30, 0x40	; 64
    22c8:	f0 e0       	ldi	r31, 0x00	; 0
    22ca:	80 81       	ld	r24, Z
    22cc:	87 6f       	ori	r24, 0xF7	; 247
    22ce:	98 2f       	mov	r25, r24
    22d0:	ed 81       	ldd	r30, Y+5	; 0x05
    22d2:	fe 81       	ldd	r31, Y+6	; 0x06
    22d4:	82 81       	ldd	r24, Z+2	; 0x02
    22d6:	8f 77       	andi	r24, 0x7F	; 127
    22d8:	89 2b       	or	r24, r25
    22da:	8c 93       	st	X, r24
CLEAR_BIT(UCSRC,UMSEL);
    22dc:	a0 e4       	ldi	r26, 0x40	; 64
    22de:	b0 e0       	ldi	r27, 0x00	; 0
    22e0:	e0 e4       	ldi	r30, 0x40	; 64
    22e2:	f0 e0       	ldi	r31, 0x00	; 0
    22e4:	80 81       	ld	r24, Z
    22e6:	8f 7b       	andi	r24, 0xBF	; 191
    22e8:	8c 93       	st	X, r24
SET_BIT(UCSRB,UCSZ2);
SET_BIT(UCSRC,UCSZ1);
SET_BIT(UCSRC,UCSZ0);
#endif

	baud_rate_value=Config_Ptr->baud_rate;
    22ea:	ed 81       	ldd	r30, Y+5	; 0x05
    22ec:	fe 81       	ldd	r31, Y+6	; 0x06
    22ee:	83 81       	ldd	r24, Z+3	; 0x03
    22f0:	94 81       	ldd	r25, Z+4	; 0x04
    22f2:	a5 81       	ldd	r26, Z+5	; 0x05
    22f4:	b6 81       	ldd	r27, Z+6	; 0x06
    22f6:	9a 83       	std	Y+2, r25	; 0x02
    22f8:	89 83       	std	Y+1, r24	; 0x01
	/* Calculate the UBRR register value */
	ubrr_value= (uint16)(((F_CPU / (baud_rate_value * 8UL))) - 1);
    22fa:	89 81       	ldd	r24, Y+1	; 0x01
    22fc:	9a 81       	ldd	r25, Y+2	; 0x02
    22fe:	cc 01       	movw	r24, r24
    2300:	a0 e0       	ldi	r26, 0x00	; 0
    2302:	b0 e0       	ldi	r27, 0x00	; 0
    2304:	88 0f       	add	r24, r24
    2306:	99 1f       	adc	r25, r25
    2308:	aa 1f       	adc	r26, r26
    230a:	bb 1f       	adc	r27, r27
    230c:	88 0f       	add	r24, r24
    230e:	99 1f       	adc	r25, r25
    2310:	aa 1f       	adc	r26, r26
    2312:	bb 1f       	adc	r27, r27
    2314:	88 0f       	add	r24, r24
    2316:	99 1f       	adc	r25, r25
    2318:	aa 1f       	adc	r26, r26
    231a:	bb 1f       	adc	r27, r27
    231c:	9c 01       	movw	r18, r24
    231e:	ad 01       	movw	r20, r26
    2320:	80 e0       	ldi	r24, 0x00	; 0
    2322:	92 e1       	ldi	r25, 0x12	; 18
    2324:	aa e7       	ldi	r26, 0x7A	; 122
    2326:	b0 e0       	ldi	r27, 0x00	; 0
    2328:	bc 01       	movw	r22, r24
    232a:	cd 01       	movw	r24, r26
    232c:	0e 94 43 12 	call	0x2486	; 0x2486 <__udivmodsi4>
    2330:	da 01       	movw	r26, r20
    2332:	c9 01       	movw	r24, r18
    2334:	01 97       	sbiw	r24, 0x01	; 1
    2336:	9c 83       	std	Y+4, r25	; 0x04
    2338:	8b 83       	std	Y+3, r24	; 0x03
		 *  By specifying 8UL, the code ensures that the division operation (F_CPU / (baud_rate * 8UL)) is performed with enough precision to accurately calculate the required baud rate divisor.*/
	//(uint16): This casts the result to a 16-bit unsigned integer type. This is likely because the UBRR (USART Baud Rate Register) is typically a 16-bit register.


	/* First 8 bits from the BAUD_PRESCALE inside UBRRL and last 4 bits in UBRRH*/
	UBRRH = ubrr_value>>8;
    233a:	e0 e4       	ldi	r30, 0x40	; 64
    233c:	f0 e0       	ldi	r31, 0x00	; 0
    233e:	8b 81       	ldd	r24, Y+3	; 0x03
    2340:	9c 81       	ldd	r25, Y+4	; 0x04
    2342:	89 2f       	mov	r24, r25
    2344:	99 27       	eor	r25, r25
    2346:	80 83       	st	Z, r24
	UBRRL = ubrr_value;
    2348:	e9 e2       	ldi	r30, 0x29	; 41
    234a:	f0 e0       	ldi	r31, 0x00	; 0
    234c:	8b 81       	ldd	r24, Y+3	; 0x03
    234e:	80 83       	st	Z, r24
}
    2350:	26 96       	adiw	r28, 0x06	; 6
    2352:	0f b6       	in	r0, 0x3f	; 63
    2354:	f8 94       	cli
    2356:	de bf       	out	0x3e, r29	; 62
    2358:	0f be       	out	0x3f, r0	; 63
    235a:	cd bf       	out	0x3d, r28	; 61
    235c:	cf 91       	pop	r28
    235e:	df 91       	pop	r29
    2360:	08 95       	ret

00002362 <UART_sendByte>:


void UART_sendByte(const uint8 data){
    2362:	df 93       	push	r29
    2364:	cf 93       	push	r28
    2366:	0f 92       	push	r0
    2368:	cd b7       	in	r28, 0x3d	; 61
    236a:	de b7       	in	r29, 0x3e	; 62
    236c:	89 83       	std	Y+1, r24	; 0x01
	/*
		 * UDRE flag is set when the Tx buffer (UDR) is empty and ready for
		 * transmitting a new byte so wait until this flag is set to one
		 */
		while(BIT_IS_CLEAR(UCSRA,UDRE)){}
    236e:	eb e2       	ldi	r30, 0x2B	; 43
    2370:	f0 e0       	ldi	r31, 0x00	; 0
    2372:	80 81       	ld	r24, Z
    2374:	88 2f       	mov	r24, r24
    2376:	90 e0       	ldi	r25, 0x00	; 0
    2378:	80 72       	andi	r24, 0x20	; 32
    237a:	90 70       	andi	r25, 0x00	; 0
    237c:	00 97       	sbiw	r24, 0x00	; 0
    237e:	b9 f3       	breq	.-18     	; 0x236e <UART_sendByte+0xc>

		/*
		 * Put the required data in the UDR register and it also clear the UDRE flag as
		 * the UDR register is not empty now
		 */
		UDR = data;
    2380:	ec e2       	ldi	r30, 0x2C	; 44
    2382:	f0 e0       	ldi	r31, 0x00	; 0
    2384:	89 81       	ldd	r24, Y+1	; 0x01
    2386:	80 83       	st	Z, r24
}
    2388:	0f 90       	pop	r0
    238a:	cf 91       	pop	r28
    238c:	df 91       	pop	r29
    238e:	08 95       	ret

00002390 <UART_recieveByte>:
uint8 UART_recieveByte(void){
    2390:	df 93       	push	r29
    2392:	cf 93       	push	r28
    2394:	cd b7       	in	r28, 0x3d	; 61
    2396:	de b7       	in	r29, 0x3e	; 62
	/* RXC flag is set when the UART receive data so wait until this flag is set to one */
		while(BIT_IS_CLEAR(UCSRA,RXC)){}
    2398:	eb e2       	ldi	r30, 0x2B	; 43
    239a:	f0 e0       	ldi	r31, 0x00	; 0
    239c:	80 81       	ld	r24, Z
    239e:	88 23       	and	r24, r24
    23a0:	dc f7       	brge	.-10     	; 0x2398 <UART_recieveByte+0x8>

		/*
		 * Read the received data from the Rx buffer (UDR)
		 * The RXC flag will be cleared after read the data
		 */
	    return UDR;
    23a2:	ec e2       	ldi	r30, 0x2C	; 44
    23a4:	f0 e0       	ldi	r31, 0x00	; 0
    23a6:	80 81       	ld	r24, Z
}
    23a8:	cf 91       	pop	r28
    23aa:	df 91       	pop	r29
    23ac:	08 95       	ret

000023ae <UART_sendString>:
void UART_sendString(const uint8 *Str)
{
    23ae:	df 93       	push	r29
    23b0:	cf 93       	push	r28
    23b2:	00 d0       	rcall	.+0      	; 0x23b4 <UART_sendString+0x6>
    23b4:	0f 92       	push	r0
    23b6:	cd b7       	in	r28, 0x3d	; 61
    23b8:	de b7       	in	r29, 0x3e	; 62
    23ba:	9b 83       	std	Y+3, r25	; 0x03
    23bc:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
    23be:	19 82       	std	Y+1, r1	; 0x01
    23c0:	0e c0       	rjmp	.+28     	; 0x23de <UART_sendString+0x30>

		/* Send the whole string */
		while(Str[i] != '\0')
		{
			UART_sendByte(Str[i]);
    23c2:	89 81       	ldd	r24, Y+1	; 0x01
    23c4:	28 2f       	mov	r18, r24
    23c6:	30 e0       	ldi	r19, 0x00	; 0
    23c8:	8a 81       	ldd	r24, Y+2	; 0x02
    23ca:	9b 81       	ldd	r25, Y+3	; 0x03
    23cc:	fc 01       	movw	r30, r24
    23ce:	e2 0f       	add	r30, r18
    23d0:	f3 1f       	adc	r31, r19
    23d2:	80 81       	ld	r24, Z
    23d4:	0e 94 b1 11 	call	0x2362	; 0x2362 <UART_sendByte>
			i++;
    23d8:	89 81       	ldd	r24, Y+1	; 0x01
    23da:	8f 5f       	subi	r24, 0xFF	; 255
    23dc:	89 83       	std	Y+1, r24	; 0x01
void UART_sendString(const uint8 *Str)
{
	uint8 i = 0;

		/* Send the whole string */
		while(Str[i] != '\0')
    23de:	89 81       	ldd	r24, Y+1	; 0x01
    23e0:	28 2f       	mov	r18, r24
    23e2:	30 e0       	ldi	r19, 0x00	; 0
    23e4:	8a 81       	ldd	r24, Y+2	; 0x02
    23e6:	9b 81       	ldd	r25, Y+3	; 0x03
    23e8:	fc 01       	movw	r30, r24
    23ea:	e2 0f       	add	r30, r18
    23ec:	f3 1f       	adc	r31, r19
    23ee:	80 81       	ld	r24, Z
    23f0:	88 23       	and	r24, r24
    23f2:	39 f7       	brne	.-50     	; 0x23c2 <UART_sendString+0x14>
		{
			UART_sendByte(Str[i]);
			i++;
		}
	}
    23f4:	0f 90       	pop	r0
    23f6:	0f 90       	pop	r0
    23f8:	0f 90       	pop	r0
    23fa:	cf 91       	pop	r28
    23fc:	df 91       	pop	r29
    23fe:	08 95       	ret

00002400 <UART_receiveString>:
/*
 * Description :
 * Receive the required string until the '#' symbol through UART from the other UART device.
 */
void UART_receiveString(uint8 *Str)
{
    2400:	0f 93       	push	r16
    2402:	1f 93       	push	r17
    2404:	df 93       	push	r29
    2406:	cf 93       	push	r28
    2408:	00 d0       	rcall	.+0      	; 0x240a <UART_receiveString+0xa>
    240a:	0f 92       	push	r0
    240c:	cd b7       	in	r28, 0x3d	; 61
    240e:	de b7       	in	r29, 0x3e	; 62
    2410:	9b 83       	std	Y+3, r25	; 0x03
    2412:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
    2414:	19 82       	std	Y+1, r1	; 0x01
    2416:	0f c0       	rjmp	.+30     	; 0x2436 <UART_receiveString+0x36>
	/* Receive the whole string until the '#' */
		while(Str[i] != '#')//'#'null ana 4mlha3lshan 2ra elstring
		{
			i++;
    2418:	89 81       	ldd	r24, Y+1	; 0x01
    241a:	8f 5f       	subi	r24, 0xFF	; 255
    241c:	89 83       	std	Y+1, r24	; 0x01
			Str[i] = UART_recieveByte();
    241e:	89 81       	ldd	r24, Y+1	; 0x01
    2420:	28 2f       	mov	r18, r24
    2422:	30 e0       	ldi	r19, 0x00	; 0
    2424:	8a 81       	ldd	r24, Y+2	; 0x02
    2426:	9b 81       	ldd	r25, Y+3	; 0x03
    2428:	8c 01       	movw	r16, r24
    242a:	02 0f       	add	r16, r18
    242c:	13 1f       	adc	r17, r19
    242e:	0e 94 c8 11 	call	0x2390	; 0x2390 <UART_recieveByte>
    2432:	f8 01       	movw	r30, r16
    2434:	80 83       	st	Z, r24
 */
void UART_receiveString(uint8 *Str)
{
	uint8 i = 0;
	/* Receive the whole string until the '#' */
		while(Str[i] != '#')//'#'null ana 4mlha3lshan 2ra elstring
    2436:	89 81       	ldd	r24, Y+1	; 0x01
    2438:	28 2f       	mov	r18, r24
    243a:	30 e0       	ldi	r19, 0x00	; 0
    243c:	8a 81       	ldd	r24, Y+2	; 0x02
    243e:	9b 81       	ldd	r25, Y+3	; 0x03
    2440:	fc 01       	movw	r30, r24
    2442:	e2 0f       	add	r30, r18
    2444:	f3 1f       	adc	r31, r19
    2446:	80 81       	ld	r24, Z
    2448:	83 32       	cpi	r24, 0x23	; 35
    244a:	31 f7       	brne	.-52     	; 0x2418 <UART_receiveString+0x18>
			i++;
			Str[i] = UART_recieveByte();
		}

		/* After receiving the whole string plus the '#', replace the '#' with '\0' */
		Str[i] = '\0';
    244c:	89 81       	ldd	r24, Y+1	; 0x01
    244e:	28 2f       	mov	r18, r24
    2450:	30 e0       	ldi	r19, 0x00	; 0
    2452:	8a 81       	ldd	r24, Y+2	; 0x02
    2454:	9b 81       	ldd	r25, Y+3	; 0x03
    2456:	fc 01       	movw	r30, r24
    2458:	e2 0f       	add	r30, r18
    245a:	f3 1f       	adc	r31, r19
    245c:	10 82       	st	Z, r1
}
    245e:	0f 90       	pop	r0
    2460:	0f 90       	pop	r0
    2462:	0f 90       	pop	r0
    2464:	cf 91       	pop	r28
    2466:	df 91       	pop	r29
    2468:	1f 91       	pop	r17
    246a:	0f 91       	pop	r16
    246c:	08 95       	ret

0000246e <__udivmodqi4>:
    246e:	99 1b       	sub	r25, r25
    2470:	79 e0       	ldi	r23, 0x09	; 9
    2472:	04 c0       	rjmp	.+8      	; 0x247c <__udivmodqi4_ep>

00002474 <__udivmodqi4_loop>:
    2474:	99 1f       	adc	r25, r25
    2476:	96 17       	cp	r25, r22
    2478:	08 f0       	brcs	.+2      	; 0x247c <__udivmodqi4_ep>
    247a:	96 1b       	sub	r25, r22

0000247c <__udivmodqi4_ep>:
    247c:	88 1f       	adc	r24, r24
    247e:	7a 95       	dec	r23
    2480:	c9 f7       	brne	.-14     	; 0x2474 <__udivmodqi4_loop>
    2482:	80 95       	com	r24
    2484:	08 95       	ret

00002486 <__udivmodsi4>:
    2486:	a1 e2       	ldi	r26, 0x21	; 33
    2488:	1a 2e       	mov	r1, r26
    248a:	aa 1b       	sub	r26, r26
    248c:	bb 1b       	sub	r27, r27
    248e:	fd 01       	movw	r30, r26
    2490:	0d c0       	rjmp	.+26     	; 0x24ac <__udivmodsi4_ep>

00002492 <__udivmodsi4_loop>:
    2492:	aa 1f       	adc	r26, r26
    2494:	bb 1f       	adc	r27, r27
    2496:	ee 1f       	adc	r30, r30
    2498:	ff 1f       	adc	r31, r31
    249a:	a2 17       	cp	r26, r18
    249c:	b3 07       	cpc	r27, r19
    249e:	e4 07       	cpc	r30, r20
    24a0:	f5 07       	cpc	r31, r21
    24a2:	20 f0       	brcs	.+8      	; 0x24ac <__udivmodsi4_ep>
    24a4:	a2 1b       	sub	r26, r18
    24a6:	b3 0b       	sbc	r27, r19
    24a8:	e4 0b       	sbc	r30, r20
    24aa:	f5 0b       	sbc	r31, r21

000024ac <__udivmodsi4_ep>:
    24ac:	66 1f       	adc	r22, r22
    24ae:	77 1f       	adc	r23, r23
    24b0:	88 1f       	adc	r24, r24
    24b2:	99 1f       	adc	r25, r25
    24b4:	1a 94       	dec	r1
    24b6:	69 f7       	brne	.-38     	; 0x2492 <__udivmodsi4_loop>
    24b8:	60 95       	com	r22
    24ba:	70 95       	com	r23
    24bc:	80 95       	com	r24
    24be:	90 95       	com	r25
    24c0:	9b 01       	movw	r18, r22
    24c2:	ac 01       	movw	r20, r24
    24c4:	bd 01       	movw	r22, r26
    24c6:	cf 01       	movw	r24, r30
    24c8:	08 95       	ret

000024ca <__prologue_saves__>:
    24ca:	2f 92       	push	r2
    24cc:	3f 92       	push	r3
    24ce:	4f 92       	push	r4
    24d0:	5f 92       	push	r5
    24d2:	6f 92       	push	r6
    24d4:	7f 92       	push	r7
    24d6:	8f 92       	push	r8
    24d8:	9f 92       	push	r9
    24da:	af 92       	push	r10
    24dc:	bf 92       	push	r11
    24de:	cf 92       	push	r12
    24e0:	df 92       	push	r13
    24e2:	ef 92       	push	r14
    24e4:	ff 92       	push	r15
    24e6:	0f 93       	push	r16
    24e8:	1f 93       	push	r17
    24ea:	cf 93       	push	r28
    24ec:	df 93       	push	r29
    24ee:	cd b7       	in	r28, 0x3d	; 61
    24f0:	de b7       	in	r29, 0x3e	; 62
    24f2:	ca 1b       	sub	r28, r26
    24f4:	db 0b       	sbc	r29, r27
    24f6:	0f b6       	in	r0, 0x3f	; 63
    24f8:	f8 94       	cli
    24fa:	de bf       	out	0x3e, r29	; 62
    24fc:	0f be       	out	0x3f, r0	; 63
    24fe:	cd bf       	out	0x3d, r28	; 61
    2500:	09 94       	ijmp

00002502 <__epilogue_restores__>:
    2502:	2a 88       	ldd	r2, Y+18	; 0x12
    2504:	39 88       	ldd	r3, Y+17	; 0x11
    2506:	48 88       	ldd	r4, Y+16	; 0x10
    2508:	5f 84       	ldd	r5, Y+15	; 0x0f
    250a:	6e 84       	ldd	r6, Y+14	; 0x0e
    250c:	7d 84       	ldd	r7, Y+13	; 0x0d
    250e:	8c 84       	ldd	r8, Y+12	; 0x0c
    2510:	9b 84       	ldd	r9, Y+11	; 0x0b
    2512:	aa 84       	ldd	r10, Y+10	; 0x0a
    2514:	b9 84       	ldd	r11, Y+9	; 0x09
    2516:	c8 84       	ldd	r12, Y+8	; 0x08
    2518:	df 80       	ldd	r13, Y+7	; 0x07
    251a:	ee 80       	ldd	r14, Y+6	; 0x06
    251c:	fd 80       	ldd	r15, Y+5	; 0x05
    251e:	0c 81       	ldd	r16, Y+4	; 0x04
    2520:	1b 81       	ldd	r17, Y+3	; 0x03
    2522:	aa 81       	ldd	r26, Y+2	; 0x02
    2524:	b9 81       	ldd	r27, Y+1	; 0x01
    2526:	ce 0f       	add	r28, r30
    2528:	d1 1d       	adc	r29, r1
    252a:	0f b6       	in	r0, 0x3f	; 63
    252c:	f8 94       	cli
    252e:	de bf       	out	0x3e, r29	; 62
    2530:	0f be       	out	0x3f, r0	; 63
    2532:	cd bf       	out	0x3d, r28	; 61
    2534:	ed 01       	movw	r28, r26
    2536:	08 95       	ret

00002538 <_exit>:
    2538:	f8 94       	cli

0000253a <__stop_program>:
    253a:	ff cf       	rjmp	.-2      	; 0x253a <__stop_program>
